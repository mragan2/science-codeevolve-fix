SETTING:
You are an expert computational geometer and optimization specialist with deep expertise in the Heilbronn triangle problem - a fundamental challenge in discrete geometry first posed by Hans Heilbronn in 1957.
This problem asks for the optimal placement of n points within a convex region of unit area to maximize the area of the smallest triangle formed by any three of these points. 
Your expertise spans classical geometric optimization, modern computational methods, and the intricate mathematical properties that govern point configurations in constrained spaces.

PROBLEM SPECIFICATION:
Design and implement a constructor function that generates an optimal arrangement of exactly 13 points within or on the boundary of a unit-area convex region. The solution must:
- Place all 13 points within or on a convex boundary
- Maximize the minimum triangle area among all C(13,3) = 286 possible triangles
- Return deterministic, reproducible results
- Execute efficiently within computational constraints

COMPUTATIONAL RESOURCES & IMPLEMENTATION GUIDELINES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Advanced optimization**: `deap` (evolutionary algorithms), `nevergrad` (gradient-free optimization)
- **Metaheuristics**: `scikit-opt` (PSO, GA, SA), `optuna` (Bayesian optimization), `hyperopt` (hyperparameter tuning)
- **Geometric computation**: `shapely` (computational geometry), `scipy.spatial` (Delaunay, Voronoi, ConvexHull), `trimesh` (mesh processing)
- **Specialized algorithms**: `cvxpy` (convex optimization), `pyomo` (optimization modeling), `casadi` (nonlinear optimization)
- **High-performance computing**: `cython` (C extensions), `dask` (parallel computing)
- **Quasi-random sequences**: `sobol_seq` for low-discrepancy initialization

PERFORMANCE METRICS:
1. **min_area_normalized**: (Area of smallest triangle) / (Area of convex hull) [PRIMARY - MAXIMIZE]
2. **benchmark_ratio**: min_area_normalized / 0.0309 [BENCHMARK COMPARISON - TARGET > 1.0]
3. **eval_time**: Execution time in seconds [EFFICIENCY - secondary priority]

TECHNICAL REQUIREMENTS:
- **Determinism**: Use fixed random seeds if employing stochastic methods for reproducibility
- **Error handling**: Graceful handling of optimization failures or infeasible configurations

# PROMPT-BLOCK-START

HIGH-LEVEL ALGORITHM OUTLINE:
1.  **Define the Objective Function**: Create a Python function that takes the 13 point coordinates as a flattened 1D array. This function must:
    *   Reshape the flattened array into `(13, 2)` points.
    *   Calculate the area of all C(13,3) = 286 possible triangles formed by these points.
    *   Compute the area of the convex hull of the 13 points using `scipy.spatial.ConvexHull`.
    *   Return the *negative* of the `min_area_normalized` metric (i.e., `-(min_triangle_area / convex_hull_area)`), as optimization routines typically perform minimization.
2.  **Set Optimization Bounds**: Define the search space for each point coordinate. For simplicity and reproducibility, assume the "unit-area convex region" is a unit square, so bounds for both x and y coordinates are `[0, 1]`.
3.  **Choose Global Optimizer**: Select a robust global optimization algorithm suitable for non-convex and potentially rugged landscapes. `scipy.optimize.differential_evolution` is highly recommended.
4.  **Execute Optimization**: Run the chosen optimizer, passing the objective function, coordinate bounds, and a fixed `seed` for determinism.
5.  **Return Optimal Configuration**: Extract and return the `(13, 2)` array of point coordinates corresponding to the optimal solution found by the optimizer.

MATHEMATICAL CONTEXT & THEORETICAL BACKGROUND:
- **PROBLEM COMPLEXITY**: The Heilbronn problem is among the most challenging in discrete geometry, with optimal configurations rigorously known only for n ≤ 4 points
- **ASYMPTOTIC BEHAVIOR**: For large n, the optimal value approaches O(1/n²) with logarithmic corrections, but the exact constant remains unknown
- **GEOMETRIC CONSTRAINTS**: Points must balance competing objectives:
  * Interior points can form larger triangles but create crowding
  * Boundary points avoid area penalties but limit triangle formation
  * Edge cases arise when three points become nearly collinear
- **SYMMETRY CONSIDERATIONS**: Optimal configurations often exhibit rotational symmetries (particularly 3-fold due to triangular geometry)
- **SCALING INVARIANCE**: The problem is scale-invariant; solutions can be normalized to any convex region
- **CRITICAL GEOMETRIC PROPERTIES**:
  * Delaunay triangulation properties and angle optimization
  * Voronoi diagram regularity as indicator of point distribution quality
  * Relationship between circumradius and triangle area
  * Connection to sphere packing and energy minimization principles

ADVANCED OPTIMIZATION STRATEGIES:
- **GLOBAL OPTIMIZATION**: Given the non-convex and multi-modal nature of the objective function, a robust global optimization algorithm is essential. `scipy.optimize.differential_evolution` is a strong candidate, capable of exploring the search space effectively.
- **CONSTRAINT HANDLING**: For points within a unit square `[0,1]x[0,1]`, simple bound constraints `(0,1)` for each coordinate are sufficient and are handled directly by optimizers like `differential_evolution`.
- **INITIALIZATION STRATEGIES**: While the optimizer often handles initialization, providing an initial population based on `Low-discrepancy sequences (Sobol, Halton)` or a `perturbed regular grid` can sometimes accelerate convergence or improve solution quality. However, `differential_evolution`'s default initialization is often robust.
- **OBJECTIVE FUNCTION DESIGN**: The primary objective is to maximize the minimum triangle area. For gradient-free optimizers like `differential_evolution`, directly using `np.min` on all calculated triangle areas is appropriate. For gradient-based methods, smooth approximations (e.g., LogSumExp) would be necessary, but are not required for the recommended approach.
- **ADVANCED TECHNIQUES**: While many advanced techniques exist, focus initially on a robust global optimization approach with a well-defined objective function, as detailed in the "Recommended implementation patterns", before exploring more complex methods.

GEOMETRIC INSIGHTS & HEURISTICS:
- **BOUNDARY CONSIDERATIONS**: Points on boundary contribute to convex hull but may form smaller triangles
- **TRIANGLE DEGENERACY**: Avoid near-collinear configurations that create arbitrarily small triangles
- **LOCAL VS GLOBAL**: Balance between locally optimal triangle sizes and global configuration harmony
- **SYMMETRY EXPLOITATION**: 3-fold rotational symmetry often appears in optimal configurations
- **VORONOI RELATIONSHIPS**: Points should have roughly equal Voronoi cell areas for optimal distribution
- **ENERGY ANALOGIES**: Treat as electrostatic repulsion or gravitational equilibrium problem
- **HISTORICAL APPROACHES**:
  * Regular lattice arrangements (suboptimal but provide baselines)
  * Hexagonal close-packing adaptations
  * Force-based relaxation (treating points as mutually repelling particles)
  * Simulated annealing and evolutionary computation
  * Gradient descent with carefully designed objective functions

**Recommended implementation patterns**:
- **OPTIMIZATION ENGINES**: For this problem, `scipy.optimize.differential_evolution` is highly recommended for its robustness in global optimization of non-convex functions. Configure it with a fixed `seed` for determinism and set the `bounds` for each point coordinate to `(0, 1)` to constrain points within a unit square.
    *   **Parameter Tuning**: Given the computational constraints (a strict 180-second time limit) and the inherent complexity of the Heilbronn problem for N=13, it is crucial to balance `maxiter` (number of generations) and `popsize` (population size) to achieve a competitive solution without timing out. A good starting point that balances exploration and execution time for N=13 is to target `maxiter` around `1000` and `popsize` around `20`. While significantly higher values might theoretically lead to a better `min_area_normalized`, they are very likely to exceed the `eval_time` limit. Prioritize finding a strong `min_area_normalized` within the time limit over an exhaustive search that times out. The `workers=-1` parameter is beneficial for parallelization.
- **OBJECTIVE FUNCTION IMPLEMENTATION**:
    -   **Input**: The objective function `func(x)` should accept a 1D `numpy` array `x` representing the flattened `(N, 2)` point coordinates.
    -   **Point Reshaping**: Reshape `x` into `points = x.reshape((N, 2))`.
    -   **Triangle Area Calculation**: Implement a vectorized approach to compute the area of all C(13,3) unique triangles. The area of a triangle with vertices `(x1, y1), (x2, y2), (x3, y3)` can be efficiently calculated using the absolute value of half the determinant of a matrix involving their coordinates: `0.5 * abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))`. Use `itertools.combinations` to generate all unique triplets of point indices.
    -   **Convex Hull Area**: Utilize `scipy.spatial.ConvexHull(points).area` to compute the area of the convex hull formed by the 13 points. Ensure `points` has at least 3 non-collinear points for a valid hull. Handle edge cases where the hull might degenerate (e.g., all points collinear) by returning a very small or penalty value.
    -   **Return Value**: The objective function *must* return the *negative* of `(min_triangle_area / convex_hull_area)`, as `scipy.optimize` functions perform minimization.
-   **AUTOMATIC DIFFERENTIATION**: Since `differential_evolution` is a gradient-free optimizer, automatic differentiation (JAX, PyTorch) is not required for the objective function. Direct `numpy` operations and `np.min` are sufficient.
-   **ACCELERATION**: `Numba` can be used to JIT compile the triangle area calculation loop for performance, especially if `itertools.combinations` generates many iterations.
-   **GRAPH ANALYSIS**: `scipy.spatial.Delaunay` can be useful for understanding the triangulation, but for calculating *all* triangle areas for N=13, direct iteration is also feasible.
-   **SYMBOLIC COMPUTATION**: SymPy is not necessary for this numerical optimization task.
-   **DATA STRUCTURES**: Pandas is not strictly necessary for the core optimization but can be useful for managing and analyzing results from multiple optimization runs or initial conditions.
-   **Efficient triangle area computation**: Prioritize `numpy` vectorized operations where possible, and use `itertools.combinations` for generating triplets.
-   **Spatial data structures**: KD-trees or spatial hashing are not strictly necessary for N=13 for the primary objective calculation, but can be helpful for auxiliary analyses like nearest neighbor statistics.

VALIDATION FRAMEWORK:
- **Geometric constraint verification**:
  * Point count validation: Exactly 13 points required
  * Convexity check: All points within or on boundary of convex hull
- **Data integrity checks**:
  * Coordinate bounds: All coordinates are finite real numbers
  * Point uniqueness: No duplicate points (within numerical tolerance)
  * Geometric consistency: Points form valid geometric configuration
- **Solution quality assessment**:
  * Local optimality testing through small perturbations
  * Symmetry analysis: Detection of rotational/reflectional symmetries
  * Distribution quality: Voronoi cell area variance, nearest neighbor statistics
  * Convergence verification: For iterative methods, check convergence criteria
- **Determinism verification**:
  * Multiple execution consistency: Same results across multiple runs
  * Seed effectiveness: Proper random seed implementation
  * Platform independence: Results stable across different computing environments

# PROMPT-BLOCK-END
    
