SETTING:
You are an expert computational geometer and optimization specialist with deep expertise in the Heilbronn triangle problem - a fundamental challenge in discrete geometry first posed by Hans Heilbronn in 1957.
This problem asks for the optimal placement of n points within a convex region of unit area to maximize the area of the smallest triangle formed by any three of these points. 
Your expertise spans classical geometric optimization, modern computational methods, and the intricate mathematical properties that govern point configurations in constrained spaces.

PROBLEM SPECIFICATION:
Design and implement a constructor function that generates an optimal arrangement of exactly 13 points within or on the boundary of a unit-area convex region. The solution must:
- Place all 13 points within or on a convex boundary
- Maximize the minimum triangle area among all C(13,3) = 286 possible triangles
- Return deterministic, reproducible results
- Execute efficiently within computational constraints

COMPUTATIONAL RESOURCES & IMPLEMENTATION GUIDELINES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Advanced optimization**: `deap` (evolutionary algorithms), `nevergrad` (gradient-free optimization)
- **Metaheuristics**: `scikit-opt` (PSO, GA, SA), `optuna` (Bayesian optimization), `hyperopt` (hyperparameter tuning)
- **Geometric computation**: `shapely` (computational geometry), `scipy.spatial` (Delaunay, Voronoi, ConvexHull), `trimesh` (mesh processing)
- **Specialized algorithms**: `cvxpy` (convex optimization), `pyomo` (optimization modeling), `casadi` (nonlinear optimization)
- **High-performance computing**: `cython` (C extensions), `dask` (parallel computing)
- **Quasi-random sequences**: `sobol_seq` for low-discrepancy initialization

PERFORMANCE METRICS:
1. **min_area_normalized**: (Area of smallest triangle) / (Area of convex hull) [PRIMARY - MAXIMIZE]
2. **benchmark_ratio**: min_area_normalized / 0.0309 [BENCHMARK COMPARISON - TARGET > 1.0]
3. **eval_time**: Execution time in seconds [EFFICIENCY - secondary priority]

TECHNICAL REQUIREMENTS:
- **Determinism**: Use fixed random seeds if employing stochastic methods for reproducibility
- **Error handling**: Graceful handling of optimization failures or infeasible configurations

# PROMPT-BLOCK-START

MATHEMATICAL CONTEXT & THEORETICAL BACKGROUND:
- **PROBLEM COMPLEXITY**: The Heilbronn problem is among the most challenging in discrete geometry, with optimal configurations rigorously known only for n ≤ 4 points
- **ASYMPTOTIC BEHAVIOR**: For large n, the optimal value approaches O(1/n²) with logarithmic corrections, but the exact constant remains unknown. For N=13, the current best-known minimum triangle area in the unit square is approximately `0.0315` (normalized by unit area). The optimization should strive to reach or exceed this benchmark.
- **GEOMETRIC CONSTRAINTS**: Points must balance competing objectives:
  * Interior points can form larger triangles but create crowding
  * Boundary points avoid area penalties but limit triangle formation
  * Edge cases arise when three points become nearly collinear
- **SYMMETRY CONSIDERATIONS**: Optimal configurations often exhibit rotational symmetries (particularly 3-fold due to triangular geometry)
- **SCALING INVARIANCE**: The problem is scale-invariant; solutions can be normalized to any convex region
- **CRITICAL GEOMETRIC PROPERTIES**:
  * Delaunay triangulation properties and angle optimization
  * Voronoi diagram regularity as indicator of point distribution quality
  * Relationship between circumradius and triangle area
  * Connection to sphere packing and energy minimization principles

ADVANCED OPTIMIZATION STRATEGIES:
- **MULTI-SCALE APPROACH**: Coarse global search → fine local refinement with adaptive step sizes
- **CONSTRAINT HANDLING**: Penalty methods, barrier functions, or projection operators for convexity
- **INITIALIZATION STRATEGIES**:
  * Perturbed regular grids (triangular, square, hexagonal lattices)
  * Random points with force-based relaxation
  * Symmetry-constrained configurations (3-fold, 6-fold rotational)
  * Hybrid boundary/interior distributions
  * Low-discrepancy sequences (Sobol, Halton) for uniform coverage
- **OBJECTIVE FUNCTION DESIGN**:
  * Smooth approximations to min() function (LogSumExp, p-norms with p→∞)
  * Barrier methods for boundary constraints
  * Multi-objective formulations balancing multiple triangle areas
  * Weighted combinations of smallest k triangle areas
- **ADVANCED TECHNIQUES**:
  * Riemannian optimization on manifolds
  * Variational methods treating point density as continuous field
  * Machine learning-guided search using learned geometric priors
  * Topological optimization considering point connectivity graphs
  * Continuation methods with parameter homotopy

GEOMETRIC INSIGHTS & HEURISTICS:
- **BOUNDARY CONSIDERATIONS**: Points on boundary contribute to convex hull but may form smaller triangles
- **TRIANGLE DEGENERACY**: Avoid near-collinear configurations that create arbitrarily small triangles
- **LOCAL VS GLOBAL**: Balance between locally optimal triangle sizes and global configuration harmony
- **SYMMETRY EXPLOITATION**: 3-fold rotational symmetry often appears in optimal configurations
- **VORONOI RELATIONSHIPS**: Points should have roughly equal Voronoi cell areas for optimal distribution
- **ENERGY ANALOGIES**: Treat as electrostatic repulsion or gravitational equilibrium problem
- **HEILBRONN N=13 SPECIFIC SYMMETRY EXPLOITATION**:
  *   For N=13, the empirically and theoretically established optimal configurations exhibit strong 3-fold rotational symmetry.
  *   To significantly reduce the dimensionality of the search space and improve convergence speed, **the point generation function should enforce this 3-fold symmetry**.
  *   **Construction for 3-fold symmetry**:
      *   Place one point at the center of the unit square (e.g., `(0.5, 0.5)`).
      *   The remaining 12 points can be defined by a smaller set of *generating points* (e.g., 4 points) that are then rotated by 120 and 240 degrees around the center point.
      *   For instance, define 4 unique points `P_1, P_2, P_3, P_4`. For each `P_i`, generate `P_i`, `rotate(P_i, 120 deg)`, `rotate(P_i, 240 deg)`. This creates 12 points from 4 generators.
      *   This reduces the number of independent variables from 26 (13 * 2) to 2 (for the center) + 8 (for 4 generating points * 2 coords) = 10 variables, or even fewer if the center is fixed.
      *   The optimization then searches for the coordinates of these `(N-1)/3` or similar generating points, rather than all N points independently. This dramatically simplifies the problem.
- **HISTORICAL APPROACHES**:
  * Regular lattice arrangements (suboptimal but provide baselines)
  * Hexagonal close-packing adaptations
  * Force-based relaxation (treating points as mutually repelling particles)
  * Simulated annealing and evolutionary computation
  * Gradient descent with carefully designed objective functions

**Recommended implementation patterns**:
- **OPTIMIZATION ENGINES**: scipy.optimize (L-BFGS-B, differential evolution, basin-hopping)
- **AUTOMATIC DIFFERENTIATION**: JAX or PyTorch for gradient-based methods
- **ACCELERATION**: Numba for JIT compilation of geometric computations
- **GRAPH ANALYSIS**: NetworkX for Delaunay triangulations and connectivity analysis
- **SYMBOLIC COMPUTATION**: SymPy for exact geometric relationships
- **DATA STRUCTURES**: Pandas for organizing multi-start optimization results
- **Efficient triangle area computation**: Vectorized cross products, avoiding expensive sqrt operations
- **Spatial data structures**: KD-trees or spatial hashing for efficient nearest neighbor queries

OPTIMIZATION WORKFLOW & IMPLEMENTATION DETAILS:
- **Objective Function `min_triangle_area_objective(flat_points)`**:
  1.  **Input**: A 1D NumPy array `flat_points` representing `N` points as `[x1, y1, x2, y2, ..., xN, yN]`.
  2.  **Reshape**: Convert `flat_points` into a `(N, 2)` array of `(x, y)` coordinates.
  3.  **Triangle Area Calculation**:
      *   Use `itertools.combinations` (from Python's standard library) to generate all `C(N, 3)` unique triplets of points.
      *   For each triplet `(p_i, p_j, p_k)`, compute the triangle area. The most numerically stable and efficient method in 2D is using half of the absolute value of the 2D cross product (determinant formula): `0.5 * abs(p_i[0]*(p_j[1]-p_k[1]) + p_j[0]*(p_k[1]-p_i[1]) + p_k[0]*(p_i[1]-p_j[1]))`.
      *   **Vectorization/Acceleration**: While `itertools.combinations` iterates, the area calculation itself can be highly vectorized using NumPy operations, or `numba.jit` can accelerate the loop for performance.
  4.  **Minimize Area**: Find the minimum absolute area among all computed triangles.
  5.  **Return Value**: The optimization goal is to *maximize* this minimum area. Therefore, the objective function must return the *negative* of the minimum area found. Note that the normalization by convex hull area (as per `min_area_normalized` metric) is applied *after* the optimization to the final result, not within the objective function itself (since the search space is a fixed unit square, its area is 1).
- **Search Domain & Constraints**:
  *   The target convex region is the unit square `[0,1]x[0,1]`.
  *   All point coordinates `x, y` must be within `[0.0, 1.0]`. This translates to `2*N` bounds for the optimizer.
- **Optimization Engine (Two-Stage Approach for Efficiency)**:
  *   **Stage 1: Global Search with `scipy.optimize.differential_evolution`**:
      *   Employ `differential_evolution` for a robust, coarse global search. This method is effective for exploring the landscape of non-smooth objective functions.
      *   **Parameters**: Tune `maxiter` (e.g., 2000-4000 iterations) and `popsize` (e.g., 100-150 individuals) to be *balanced* between exploration and computational budget. The goal is to find a robust starting region within a reasonable timeframe (e.g., aiming for overall execution time under 60-90 seconds), not necessarily the exact optimum in this stage. Consider `K_runs` (number of independent DE runs) in the range of 5-10 for robust global coverage.
      *   **Determinism**: Set the `seed` parameter (e.g., 42) for reproducibility.
  *   **Stage 2: Local Refinement with `scipy.optimize.minimize`**:
      *   Take the best result (`result.x`) from `differential_evolution` as the initial guess for a local optimization step.
      *   Use a gradient-based local optimizer from `scipy.optimize.minimize`, such as `method='L-BFGS-B'` or `method='SLSQP'`, as these methods efficiently handle bounds.
      *   **Parameters**: `num_local_restarts` should be moderate (e.g., 5-10 restarts). For each local run, set `maxiter` to a reasonable value (e.g., 1000-2000 iterations) to ensure sufficient refinement without excessive runtime.
      *   **Objective Function for Local Refinement**: The same `min_triangle_area_objective` can be used. For better performance with gradient-based methods, consider using a smooth approximation of `min()` (e.g., LogSumExp) if the direct `min()` causes issues with gradients, though `L-BFGS-B` can be robust to non-smoothness.
      *   **Determinism**: Ensure any stochastic components (if applicable, though local optimizers are often deterministic given a starting point) are seeded.
- **Initialization for Stage 1**: While `differential_evolution` has its own initialization, for highly specific problems, generating an initial population using low-discrepancy sequences (e.g., `scipy.stats.qmc.Sobol`) and passing it via the `init` parameter is highly beneficial for the global search.
- **Final Output**: After the optimization stages complete, the `x` attribute of the `OptimizeResult` object will contain the `flat_points` array corresponding to the optimal configuration. This array should be reshaped to `(N, 2)` for the final point arrangement.

VALIDATION FRAMEWORK:
- **Geometric constraint verification**:
  * Point count validation: Exactly 13 points required
  * Convexity check: All points within or on boundary of convex hull
- **Data integrity checks**:
  * Coordinate bounds: All coordinates are finite real numbers
  * Point uniqueness: No duplicate points (within numerical tolerance)
  * Geometric consistency: Points form valid geometric configuration
- **Solution quality assessment**:
  * Local optimality testing through small perturbations
  * Symmetry analysis: Detection of rotational/reflectional symmetries
  * Distribution quality: Voronoi cell area variance, nearest neighbor statistics
  * Convergence verification: For iterative methods, check convergence criteria
- **Determinism verification**:
  * Multiple execution consistency: Same results across multiple runs
  * Seed effectiveness: Proper random seed implementation
  * Platform independence: Results stable across different computing environments

# PROMPT-BLOCK-END
    
