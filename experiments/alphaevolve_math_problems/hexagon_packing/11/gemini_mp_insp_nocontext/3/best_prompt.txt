SETTING:
You are an expert computational geometer and optimization specialist focusing on hexagon packing problems.
Your task is to evolve a constructor function that generates an optimal arrangement of exactly 11 unit regular hexagons within a larger regular hexagon, maximizing 1/outer_hex_side_length (equivalently minimizing the outer hexagon's side length).

PROBLEM CONTEXT:
- Target: Beat the current state-of-the-art benchmark of 1/outer_hex_side_length = 1/3.931 ≈ 0.2544
- Constraint: All 11 inner hexagons must be unit regular hexagons (side length = 1) that are fully contained within the outer hexagon with no overlaps
- Mathematical formulation: For hexagon i at position (xi, yi) with rotation θi:
  * Non-overlap: All pairs of inner hexagons must be disjoint
  * Containment: All vertices of inner hexagons must lie within the outer hexagon
  * Objective: maximize 1/R where R is the outer hexagon side length

PERFORMANCE METRICS:
1. **inv_outer_hex_side_length**: 1/outer_hex_side_length (PRIMARY OBJECTIVE - maximize)
2. **benchmark_ratio**: inverse_side_length / 0.2544 (progress toward beating SOTA)
3. **eval_time**: Execution time for full evaluation

COMPUTATIONAL RESOURCES & IMPLEMENTATION GUIDELINES:
**Core packages**: numpy, scipy, matplotlib, shapely
**Additional useful packages**:
- **Geometric computing**: 
  * `shapely` (polygon operations, intersection testing, containment checks)
  * `scipy.spatial` (distance calculations, geometric queries)
- **Optimization**: 
  * `scipy.optimize` (constrained optimization, global methods)
  * `deap` (evolutionary algorithms with custom operators)
  * `platypus` (multi-objective optimization)
- **Collision detection**: 
  * `pymunk` (2D rigid body physics with polygon shapes)
  * Custom SAT (Separating Axis Theorem) implementations
- **Performance**: `numba` (JIT compilation for geometric calculations), `joblib`

TECHNICAL REQUIREMENTS:
- **Numerical stability**: Handle hexagon intersection and containment calculations robustly
- **Reproducibility**: Fixed random seeds for stochastic optimization methods

# PROMPT-BLOCK-START

**Recommended implementation patterns:**
*   **Hexagon Representation:**
    *   Define a `Hexagon` class or utility functions that return `shapely.geometry.Polygon` objects. A hexagon can be defined by its `(center_x, center_y, angle_degrees, side_length)`. For unit hexagons, `side_length` is 1.
    *   A helper function `create_hexagon_polygon(center_x, center_y, angle_degrees, side_length=1.0)` is essential for consistent polygon generation.
    *   The `angle_degrees` should represent the rotation of the hexagon, typically around its center. An angle of 0 degrees means one pair of sides is parallel to the x-axis.
*   **Objective Function:**
    *   Implement a single objective function, `evaluate_packing(parameters)`, that takes a flattened array of variables (e.g., `[x1, y1, a1, x2, y2, a2, ...]`) and returns the `outer_hex_side_length` to be minimized.
    *   This function must:
        1.  Parse the `parameters` array into 11 `(x, y, angle)` tuples for the inner hexagons.
        2.  Convert these into `shapely.geometry.Polygon` objects.
        3.  Check for overlaps between inner hexagons (using `shapely.Polygon.disjoint`). If overlaps occur, return a very large penalty value (e.g., `100.0`) to guide the optimizer away from invalid configurations.
        4.  Calculate the side length `R` of the smallest regular hexagon that encloses all 11 inner hexagons. This `R` is the value to be minimized.
*   **Constraints:** While `scipy.optimize.minimize` can handle explicit constraints, for global optimization methods like Differential Evolution, it's often more effective to incorporate non-overlap and containment checks directly into the objective function as penalties.
*   **Visualization Utility:** A function `plot_packing(inner_hex_data, outer_hex_side_length, ax)` using `matplotlib` to visualize the current state of the packing for debugging and result presentation.

OPTIMIZATION STRATEGIES TO CONSIDER:
*   **Global Optimization:** Given the high-dimensional (33 variables: 11 hexagons * 3 (x, y, angle)) and highly non-convex nature of the search space, global optimization algorithms are crucial to avoid local minima.
    *   `scipy.optimize.differential_evolution`: This is a robust global optimization algorithm well-suited for problems with many local minima. It requires bounds for each variable.
    *   `scipy.optimize.basinhopping`: Combines local optimization with random jumps to escape local minima.
    *   Evolutionary Algorithms (`deap`, `platypus`): Offer more flexibility for custom operators and multi-objective optimization, but might require more setup.
*   **Initial Guess/Population:** A good starting point can significantly improve optimization performance.
    *   **Heuristic placement:** Consider placing one hexagon at the origin, then arranging others in a common hexagonal packing pattern (e.g., a central hexagon surrounded by 6, then 4 more strategically placed).
    *   **Random placement:** For global optimizers, a diverse initial population generated randomly within reasonable bounds is also effective.
*   **Hybrid Approaches:** Often, a global optimizer can find a good region, and then a local optimizer (`scipy.optimize.minimize` with methods like `L-BFGS-B` or `SLSQP`) can fine-tune the solution for better precision.
*   **Symmetry Exploitation:** Optimal packings for N=11 often exhibit C6 symmetry. Consider enforcing this symmetry in the variable definitions or the objective function to reduce the search space complexity. For example, fix the central hexagon at (0,0,0) and arrange other hexagons symmetrically.

GEOMETRIC INSIGHTS & MATHEMATICAL FOUNDATIONS:
*   **Unit Hexagon Properties:** A unit regular hexagon (side length `s=1`) has an apothem (inradius) of `r = s * sqrt(3)/2 = sqrt(3)/2`. The distance between parallel sides is `2r = sqrt(3)`. The circumradius is `s=1`.
*   **Vertices Calculation:** For a hexagon centered at `(cx, cy)` with side length `s` and angle `theta_degrees`, its 6 vertices can be calculated as `(cx + s * cos(angle), cy + s * sin(angle))` for `angle` values of `theta_radians + k * pi/3` where `k` ranges from 0 to 5.
*   **Non-overlap Check:** Use `shapely.geometry.Polygon.disjoint(other_polygon)` to ensure no overlaps between inner hexagons. This is more robust than simple bounding box checks.
*   **Minimum Enclosing Regular Hexagon (MERH):** To calculate `outer_hex_side_length` for a given arrangement of inner hexagons:
    1.  Collect all vertices from all 11 inner hexagons.
    2.  For each of the six primary hexagonal orientations (e.g., 0, 60, 120 degrees relative to the x-axis), find the maximum extent of the collected vertices along the perpendicular axis.
    3.  Specifically, for angles `phi` = `0, pi/3, 2*pi/3, pi, 4*pi/3, 5*pi/3` (representing directions perpendicular to the sides of the outer hexagon), calculate `max_extent_phi = max(x * cos(phi) + y * sin(phi))` for all inner hexagon vertices `(x,y)`.
    4.  The `outer_hex_side_length` `R` is then derived from these extents. If the outer hexagon is centered at `(0,0)` and aligned with the coordinate axes (e.g., flat top/bottom), its side length `R` is `(max_x_extent - min_x_extent) / 2` and `(max_y_extent - min_y_extent) / sqrt(3)`. More generally, the side length `R` is the maximum of `(max_extent_phi - min_extent_phi) / sqrt(3)` over the 3 unique orientations. A simpler way is to find the convex hull of all inner hexagon vertices (`shapely.geometry.MultiPoint(all_vertices).convex_hull`) and then compute the smallest enclosing regular hexagon for this convex hull.

VALIDATION FRAMEWORK:
*   **`is_valid_packing(inner_hex_polygons, outer_hex_side_length)` function:**
    *   This function should take a list of `shapely.Polygon` objects for the inner hexagons and the calculated `outer_hex_side_length`.
    *   Check for non-overlap: Iterate through all unique pairs of inner hexagons `(h_i, h_j)` and assert `h_i.disjoint(h_j)`.
    *   Check for containment: Construct the outer hexagon `outer_hex_polygon` (centered at (0,0) for simplicity, with the given `outer_hex_side_length`). Then, for each inner hexagon `h_i`, assert `outer_hex_polygon.contains(h_i)`.
    *   Return `True` if all conditions are met, `False` otherwise.
*   **Numerical Precision:** Be mindful of floating-point inaccuracies when checking for overlaps and containment. `shapely` operations typically handle this well, but for custom checks, introduce small tolerances.
*   **Visual Debugging:** The `plot_packing` function is critical for understanding why certain packings are invalid or suboptimal. It should clearly show inner hexagons, the calculated outer hexagon, and any overlaps if they occur.

PROBLEM-SPECIFIC CONSIDERATIONS:
*   **High-Dimensional Search Space:** With 33 continuous variables, the search space is vast. This reinforces the need for robust global optimization techniques.
*   **Non-Convexity:** The objective function is highly non-convex, meaning there are many local minima. Standard gradient-based optimizers will easily get stuck.
*   **Numerical Stability:** Geometric calculations, especially intersection and containment, require careful handling of floating-point numbers. `shapely` is generally robust in this regard.
*   **Benchmark Reference:** The target `1/3.931` (or `R=3.931`) is a very tight packing. Solutions will require precise positioning and rotation of the inner hexagons.
*   **Boundary Conditions:** Hexagons touching the boundary of the outer hexagon are common in optimal packings. The containment check should accurately handle these "touching" scenarios.
*   **Computational Cost:** The objective function involves 11 * 10 / 2 = 55 pairwise overlap checks and 11 containment checks per evaluation. This can be computationally intensive, so efficient geometric operations are important. `numba` could be useful for accelerating custom geometric calculations if `shapely` proves to be a bottleneck for very large populations or iterations.

# PROMPT-BLOCK-END
    
