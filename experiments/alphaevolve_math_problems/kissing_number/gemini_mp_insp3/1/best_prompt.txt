PERFORMANCE METRICS:
1.  **num_points**: The number of points in the final set $S$. **This is the primary objective to maximize.**
2.  **benchmark_ratio**: Your `num_points` / 593. The goal is to achieve a ratio > 1.0.
3.  **eval_time**: The total wall-clock time in seconds to generate the solution.

COMPUTATIONAL RESOURCES & IMPLEMENTATION GUIDELINES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Optimization**: `deap` (evolutionary algorithms), `platypus` (multi-objective optimization)
- **Geometric computing**: `shapely` (geometric operations), `rtree` (spatial indexing), `scipy.spatial` (KDTree, Voronoi)
- **Constraint programming**: `python-constraint`, `ortools` (Google OR-Tools)
- **Physics simulation**: `pymunk` (2D physics), `pybullet` (physics engine)
- **Performance**: `cython`, `joblib` (parallelization), 'numba' (JIT)

TECHNICAL REQUIREMENTS:
- **Determinism & Reproducibility**: Your solution must be fully reproducible. If you use any stochastic algorithms (like simulated annealing or genetic algorithms), you **must use a fixed random seed** (e.g., `numpy.random.seed(42)`).
- **Efficiency**: While secondary to correctness and the number of points, your algorithm should be reasonably efficient. Avoid brute-force searches over the entire $\mathbb{Z}^{11}$ lattice, which is computationally infeasible.

# PROMPT-BLOCK-START

SETTING:
The goal is to construct the largest possible set $S$ of distinct points in an 11-dimensional space, where each point has integer coordinates. The set $S$ must satisfy a specific geometric condition: the maximum Euclidean norm of any point in $S$ must be strictly less than the minimum pairwise Euclidean distance between any two distinct points in $S$. Your objective is to maximize the number of points in $S$.

PROBLEM CONTEXT:
This problem is a variant of classical sphere packing or kissing number problems, but with the additional constraint tying the points' distances from the origin to their pairwise distances. We are seeking to maximize the number of points (`num_points`) in $S$. The requirement for integer coordinates means we are searching within the $\mathbb{Z}^{11}$ lattice. High-dimensional spaces often allow for dense packings and highly symmetric structures. The large benchmark value (593 points) suggests that a simple brute-force enumeration over a vast space is infeasible and that a constructive approach leveraging geometric and combinatorial properties is necessary.

OPTIMIZATION STRATEGIES TO CONSIDER:
1.  **Exploit Symmetry**: Due to the nature of Euclidean distance and integer coordinates, if a point $p=(x_1, ..., x_{11})$ is in $S$, then its permutations, sign changes (e.g., $(-x_1, x_2, ..., x_{11})$), or combinations thereof, are often also valid candidates for inclusion. This can significantly reduce the search space by generating a canonical form and then applying symmetries.
2.  **Constructive Approach - Fixed Squared Norm**: A powerful strategy is to consider sets $S$ where all points $p \in S$ have the *same* squared Euclidean norm, say $||p||^2 = k$. In this case, $M_N = \sqrt{k}$. The challenge then becomes to find the minimum pairwise distance $m_D$ for this specific set of points and ensure that $\sqrt{k} < m_D$. Iterate through small integer values of $k$ (e.g., $k=1, 2, 3, ...$) to find a suitable set.
3.  **Efficient Verification**: Calculating all pairwise distances for a large set can be computationally intensive. Optimize this step by leveraging `numpy` vectorization.

GEOMETRIC INSIGHTS & MATHEMATICAL FOUNDATIONS:
1.  **Euclidean Norm and Integer Coordinates**: For any point $p=(x_1, ..., x_{11})$ with $x_i \in \mathbb{Z}$, its squared Euclidean norm $||p||^2 = \sum x_i^2$ is an integer. Similarly, for $p, q \in \mathbb{Z}^{11}$, the squared Euclidean distance $||p-q||^2$ is also an integer. This allows us to work with squared norms and distances, avoiding floating-point precision issues until the final comparison.
2.  **The Condition $M_N < m_D$**:
    *   $M_N = \max_{p \in S} ||p||$.
    *   $m_D = \min_{p \ne q \in S} ||p-q||$.
    *   This condition implies that all points are relatively "close" to the origin but "far apart" from each other.
    *   If all points in $S$ have the same squared norm $k$, then $M_N = \sqrt{k}$. The condition simplifies to $\sqrt{k} < m_D$, which is equivalent to $k < m_D^2$.
3.  **High-Dimensional Geometry**: In higher dimensions, dense packings often arise from highly symmetric configurations.
4.  **Promising Candidate Structure**: A particularly effective strategy for this problem in 11 dimensions is to consider points where exactly three coordinates are $\pm 1$ and the remaining eight coordinates are $0$.
    *   For any such point $p$, its squared Euclidean norm is $||p||^2 = (\pm 1)^2 + (\pm 1)^2 + (\pm 1)^2 = 1+1+1=3$.
    *   Thus, for a set $S$ consisting *only* of such points, $M_N = \sqrt{3}$.
    *   Now, let's find the minimum pairwise squared distance $m_D^2$ between any two distinct points $p, q$ in this set.
        *   Consider $p=(1,1,1,0,...,0)$ and $q=(1,1,-1,0,...,0)$. The squared distance is $||p-q||^2 = (1-1)^2+(1-1)^2+(1-(-1))^2 = 0^2+0^2+2^2 = 4$.
        *   **CRITICAL CORRECTION**: Consider $p=(1,1,1,0,...,0)$ and $q=(1,1,0,1,0,...,0)$. These are both valid points in the proposed set. Their squared distance is $||p-q||^2 = (1-1)^2+(1-1)^2+(1-0)^2+(0-1)^2 = 0^2+0^2+1^2+(-1)^2 = 2$.
        *   Consider $p=(1,1,1,0,...,0)$ and $q=(1,-1,-1,0,...,0)$. The squared distance is $||p-q||^2 = (1-1)^2+(1-(-1))^2+(1-(-1))^2 = 0^2+2^2+2^2 = 8$.
        *   Consider $p=(1,1,1,0,...,0)$ and $q=(-1,-1,-1,0,...,0)$. The squared distance is $||p-q||^2 = (1-(-1))^2+(1-(-1))^2+(1-(-1))^2 = 2^2+2^2+2^2 = 12$.
    *   Therefore, the actual minimum squared distance $m_D^2$ for this set is 2, so $m_D = \sqrt{2}$.
    *   The maximum squared norm $M_N^2$ for this set is 3 (so $M_N = \sqrt{3}$).
    *   The condition $M_N < m_D$ becomes $\sqrt{3} < \sqrt{2}$, which is false (since $3 \not< 2$).
    *   **Conclusion on this structure**: This specific candidate structure (points with exactly three $\pm 1$ coordinates) does *not* satisfy the problem's geometric condition. While it generates $2^3 \times \binom{11}{3} = 1320$ points, the points are too close to each other relative to their distance from the origin.
    *   **Revised Guidance**: To satisfy the condition $M_N^2 < m_D^2$, we must ensure a greater separation between points relative to their norm. For example:
        *   If $M_N^2 = 1$ (points with one $\pm 1$ coordinate), then $m_D^2 = 2$. The condition $1 < 2$ is true. This yields $2 \times \binom{11}{1} = 22$ points. This set is valid but too small.
        *   If $M_N^2 = 4$ (points with one $\pm 2$ coordinate), then $m_D^2 = 8$. The condition $4 < 8$ is true. This yields $2 \times \binom{11}{1} = 22$ points. This set is also valid but too small.
        *   Achieving a large number of points (like 593) while satisfying the strict $M_N^2 < m_D^2$ condition will likely require a more complex constructive approach. This could involve:
            1.  Generating a larger initial set (e.g., the 1320 points with $M_N^2=3$) and then applying a **filtering algorithm** to remove points that violate the minimum distance constraint, or to keep only a maximal subset that satisfies the constraint. This filtering would need to ensure $m_D^2 > M_N^2$. For $M_N^2=3$, this means $m_D^2 \ge 4$.
            2.  Exploring points with different combinations of coordinate values (e.g., $0, \pm 1, \pm 2$) or specific parity constraints.
            3.  Leveraging techniques from coding theory to construct sets with guaranteed minimum distances.

Recommended implementation patterns:
1.  **Numpy for numerical operations**: Utilize `numpy` arrays for representing points and for efficient vector operations (e.g., `np.linalg.norm` or `np.sum` for squared norms/distances).
2.  **`itertools` for combinations/permutations**: Efficiently generate base vectors (e.g., a vector with three 1s and eight 0s) and then use `itertools.permutations` and sign flips to generate the full set of points.
3.  **Pre-computation**: Calculate squared norms and squared distances to avoid repeated `sqrt` calls until the final comparison, and to keep calculations integer-based where possible.
4.  **Modular Design**: Break down the problem into smaller, testable functions: one to generate points for a given squared norm, another to calculate pairwise distances (or just the minimum pairwise distance), and a third to verify the condition.
5.  **Memory Management**: For large sets, consider optimizing pairwise distance calculations. For the 1320-point set, a direct pairwise distance calculation should be feasible within memory and time limits.

# PROMPT-BLOCK-END
