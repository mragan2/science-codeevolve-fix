SETTING:
You are an expert in high-dimensional geometry, lattice theory, and combinatorial optimization, specializing in sphere packing and coding theory problems.
Your task is to devise a computational strategy and generate a set of points that provides a new state-of-the-art lower bound for a specific variant of the kissing number problem in 11 dimensions.

PROBLEM CONTEXT:
Your goal is to find the largest possible set of points $S \subset \mathbb{Z}^{11}$ (points with 11 integer coordinates) that satisfies the following geometric constraint: the maximum L2 norm of any point from the origin must be less than or equal to the minimum pairwise L2 distance between any two distinct points in the set.

- **Target**: Beat the AlphaEvolve benchmark of **num_points = 593**.
- **Constraint**: For the set of points $S = \{p_1, p_2, ..., p_k\}$ where $p_i \in \mathbb{Z}^{11}$:
  $$\max_{i} \|p_i\|_2 \le \min_{i \neq j} \|p_i - p_j\|_2$$
- **Objective**: Maximize the cardinality of the set, $k = |S|$.

PERFORMANCE METRICS:
1.  **num_points**: The number of points in the final set $S$. **This is the primary objective to maximize.**
2.  **benchmark_ratio**: Your `num_points` / 593. The goal is to achieve a ratio > 1.0.
3.  **eval_time**: The total wall-clock time in seconds to generate the solution.

COMPUTATIONAL RESOURCES & IMPLEMENTATION GUIDELINES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Optimization**: `deap` (evolutionary algorithms), `platypus` (multi-objective optimization)
- **Geometric computing**: `shapely` (geometric operations), `rtree` (spatial indexing), `scipy.spatial` (KDTree, Voronoi)
- **Constraint programming**: `python-constraint`, `ortools` (Google OR-Tools)
- **Physics simulation**: `pymunk` (2D physics), `pybullet` (physics engine)
- **Performance**: `cython`, `joblib` (parallelization), 'numba' (JIT)

TECHNICAL REQUIREMENTS:
- **Determinism & Reproducibility**: Your solution must be fully reproducible. If you use any stochastic algorithms (like simulated annealing or genetic algorithms), you **must use a fixed random seed** (e.g., `numpy.random.seed(42)`).
- **Efficiency**: While secondary to correctness and the number of points, your algorithm should be reasonably efficient. Avoid brute-force searches over the entire $\mathbb{Z}^{11}$ lattice, which is computationally infeasible.

# PROMPT-BLOCK-START

OPTIMIZATION STRATEGIES TO CONSIDER:
1.  **Iterative Search over $R^2$**: The problem implies that all points in an optimal set $S$ (if $|S|>1$) must have the same L2 norm, $R$. Since points are in $\mathbb{Z}^{11}$, $R^2$ must be an integer. Let $N = R^2$. The strategy should involve iterating over plausible integer values for $N$ (starting from small values like 1, 2, 3...) and for each $N$:
    a.  Generate all unique integer points $p \in \mathbb{Z}^{11}$ such that $\|p\|_2^2 = N$. This involves solving the "sum of 11 squares" problem for $N$.
    b.  From this pool of candidate points, select a maximal subset $S$ that satisfies the minimum distance constraint: for any two distinct points $p_i, p_j \in S$, their squared L2 distance $\|p_i - p_j\|_2^2$ must be greater than or equal to $N$.
    c.  Keep track of the largest $|S|$ found across all $N$ values. The origin $(0, \dots, 0)$ is unlikely to be part of an optimal solution with $N > 0$, as its norm is 0, which would contradict the 'all points have same norm $R$' insight.

2.  **Symmetry Exploitation**: Optimal high-dimensional sphere packings typically exhibit significant symmetry.
    a.  **Efficient point generation**: Instead of exhaustively searching $\mathbb{Z}^{11}$, generate a canonical set of points (e.g., points with $x_1 \ge x_2 \ge \dots \ge x_{11} \ge 0$) that sum of squares to $N$. Then, apply all possible permutations of coordinates and sign changes to these canonical points to generate the full set of candidate points for a given $N$. This drastically reduces the initial search space.
    b.  **Set building**: When selecting points for $S$, if a canonical point is chosen, consider adding its entire orbit (all points generated by permutations and sign changes) to $S$ if the entire orbit satisfies the distance constraints.

3.  **Greedy Construction / Local Search**:
    a.  For a fixed $N$ and the full set of candidate points $P_N = \{p \in \mathbb{Z}^{11} \mid \|p\|_2^2 = N\}$, start with an empty set $S$.
    b.  Iteratively add points from $P_N$ to $S$. At each step, choose a point $p \in P_N \setminus S$ that satisfies the minimum distance constraint with all points currently in $S$. Prioritize points that maximize separation from existing points, or points that are part of larger symmetric orbits.
    c.  Consider using randomized greedy approaches or local search heuristics (e.g., simulated annealing, genetic algorithms using `deap`) to explore the space of valid point sets for a fixed $N$, especially if the initial greedy choice proves suboptimal.

GEOMETRIC INSIGHTS & MATHEMATICAL FOUNDATIONS:
1.  **All points lie on a sphere**: A critical deduction from the constraint $\max_{i} \|p_i\|_2 \le \min_{i \neq j} \|p_i - p_j\|_2$ is that all points $p \in S$ (excluding the origin if $S$ contained it and $R>0$) must have the exact same L2 norm. Let this norm be $R$. Thus, $\|p\|_2 = R$ for all $p \in S$. The origin $\mathbf{0}$ can only be part of $S$ if $R=0$, which implies $S=\{\mathbf{0}\}$. For non-trivial sets, $R>0$.

2.  **Squared Distances and Integer Norms**: Since $p_i \in \mathbb{Z}^{11}$, $\|p_i\|_2^2 = R^2$ must be an integer. Let $N = R^2$. The constraint then simplifies to:
    *   For all $p \in S$, $\|p\|_2^2 = N$.
    *   For any distinct $p_i, p_j \in S$, their squared L2 distance $\|p_i - p_j\|_2^2 \ge N$.

3.  **Angular Separation**: The condition $\|p_i - p_j\|_2^2 \ge N$ implies $2N - 2 p_i \cdot p_j \ge N$, which simplifies to $p_i \cdot p_j \le N/2$. This means the cosine of the angle $\theta$ between any two distinct vectors $p_i, p_j$ must satisfy $\cos \theta = \frac{p_i \cdot p_j}{\|p_i\|_2 \|p_j\|_2} = \frac{p_i \cdot p_j}{N} \le \frac{N/2}{N} = 1/2$. Thus, the angle between any two distinct vectors must be at least $\pi/3$ (60 degrees). This is a strong geometric constraint on the arrangement of points, indicating a "well-separated" spherical code.

4.  **Common Optimal Configurations**: For problems of this nature, optimal configurations often involve points with a small number of non-zero coordinates, where those coordinates are $\pm 1$. For example, points that are permutations and sign changes of $(1,1,1,0,\dots,0)$ have $N=3$. This specific configuration yields 1320 points, which significantly surpasses the benchmark of 593. The AI should prioritize exploring such highly symmetric structures.

**Recommended implementation patterns**:
1.  **Efficient Point Generation**: Implement a recursive or iterative function to generate all integer points $p = (x_1, \dots, x_{11})$ such that $\sum_{i=1}^{11} x_i^2 = N$. A common approach is to generate points with non-negative, non-increasing coordinates first, and then apply permutations and sign changes.
2.  **`numpy` for Vectorized Operations**: Utilize `numpy` arrays for representing points and performing fast L2 norm and distance calculations.
3.  **`scipy.spatial.KDTree`**: When building the set $S$, for each new candidate point, efficiently check its distance to all existing points in $S$. A `KDTree` can speed up nearest neighbor searches significantly, making the distance constraint checking much faster.
4.  **`numba` for JIT Compilation**: For computationally intensive parts of the algorithm (e.g., specific loops in point generation, distance checks, or fitness function evaluations in evolutionary algorithms), use `numba.jit` to compile Python code to machine code for C-like performance.
5.  **Set Data Structure for Points**: Store the points in `S` as a `set` of tuples (or `frozenset` of tuples) to ensure uniqueness and fast lookup, converting to `numpy.ndarray` only when performing numerical calculations.
6.  **Progressive Search**: Start with small integer values of $N = R^2$ (e.g., $N=1, 2, 3, \dots$) and incrementally increase it. The optimal configuration for 593 points is likely to have a relatively small $N$. The search process should be designed to be bounded by the `eval_time` limit.
7.  **Reproducibility**: Ensure `numpy.random.seed(42)` is used if any randomized component is introduced in the search strategy.

# PROMPT-BLOCK-END
