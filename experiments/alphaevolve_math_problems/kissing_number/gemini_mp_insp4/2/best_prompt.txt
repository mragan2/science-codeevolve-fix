SETTING:
You are an expert in high-dimensional geometry, lattice theory, and combinatorial optimization, specializing in sphere packing and coding theory problems.
Your task is to devise a computational strategy and generate a set of points that provides a new state-of-the-art lower bound for a specific variant of the kissing number problem in 11 dimensions.

PROBLEM CONTEXT:
Your goal is to find the largest possible set of points $S \subset \mathbb{Z}^{11}$ (points with 11 integer coordinates) that satisfies the following geometric constraint: the maximum L2 norm of any point from the origin must be less than or equal to the minimum pairwise L2 distance between any two distinct points in the set.

- **Target**: Beat the AlphaEvolve benchmark of **num_points = 593**.
- **Constraint**: For the set of points $S = \{p_1, p_2, ..., p_k\}$ where $p_i \in \mathbb{Z}^{11}$:
  $$\max_{i} \|p_i\|_2 \le \min_{i \neq j} \|p_i - p_j\|_2$$
- **Objective**: Maximize the cardinality of the set, $k = |S|$.

PERFORMANCE METRICS:
1.  **num_points**: The number of points in the final set $S$. **This is the primary objective to maximize.**
2.  **benchmark_ratio**: Your `num_points` / 593. The goal is to achieve a ratio > 1.0.
3.  **eval_time**: The total wall-clock time in seconds to generate the solution.

COMPUTATIONAL RESOURCES & IMPLEMENTATION GUIDELINES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Optimization**: `deap` (evolutionary algorithms), `platypus` (multi-objective optimization)
- **Geometric computing**: `shapely` (geometric operations), `rtree` (spatial indexing), `scipy.spatial` (KDTree, Voronoi)
- **Constraint programming**: `python-constraint`, `ortools` (Google OR-Tools)
- **Physics simulation**: `pymunk` (2D physics), `pybullet` (physics engine)
- **Performance**: `cython`, `joblib` (parallelization), 'numba' (JIT)

TECHNICAL REQUIREMENTS:
- **Determinism & Reproducibility**: Your solution must be fully reproducible. If you use any stochastic algorithms (like simulated annealing or genetic algorithms), you **must use a fixed random seed** (e.g., `numpy.random.seed(42)`).
- **Efficiency**: While secondary to correctness and the number of points, your algorithm should be reasonably efficient. Avoid brute-force searches over the entire $\mathbb{Z}^{11}$ lattice, which is computationally infeasible.

# PROMPT-BLOCK-START

OPTIMIZATION STRATEGIES TO CONSIDER:
To achieve a state-of-the-art lower bound, a sophisticated search or constructive approach is essential. Brute-force over the entire lattice is computationally infeasible. Consider the following:

1.  **Symmetry-Driven Construction**:
    *   **Base Vectors**: Start with a small set of "seed" integer vectors. These seeds should be chosen based on geometric insights (e.g., vectors with a small number of non-zero coordinates, or specific coordinate values like $\pm 1, \pm 2$).
    *   **Symmetry Expansion**: Generate a much larger set by applying all possible permutations of coordinates and sign changes to these base vectors. This drastically reduces the search space for highly symmetric solutions, which are often optimal in such packing problems.
    *   **Filtering**: From the expanded set, carefully select a subset that satisfies the geometric constraint.

2.  **Iterative Greedy/Local Search**:
    *   **Candidate Pool Generation**: Create a large pool of promising integer points. This pool can be generated by:
        *   Enumerating points with small squared L2 norms (e.g., up to a certain threshold, like 1, 2, 3, 4, etc.).
        *   Utilizing known lattice structures (e.g., points from the D_11 lattice).
        *   Generating permutations and sign changes of simple vectors (e.g., $(\pm 1, \pm 1, 0, ..., 0)$, $(\pm 2, 0, ..., 0)$).
    *   **Greedy Addition**: Start with a small, valid set (e.g., the 22 points of type $(\pm 1, 0, ..., 0)$ or the 220 points of type $(\pm 1, \pm 1, 0, ..., 0)$, which are known to satisfy the condition independently). Iteratively add points from the candidate pool that maintain the geometric constraint and maximize the set cardinality. Prioritize candidates that are "far" from existing points and have relatively small norms.
    *   **Local Optimization**: After an initial set is constructed, perform local search operations: try removing points, adding new ones from the candidate pool, or slightly perturbing coordinates of existing points to find improvements.

3.  **Evolutionary Algorithms (e.g., using `deap`)**:
    *   **Representation**: A "chromosome" could be a set of 11-dimensional integer points.
    *   **Fitness Function**: Maximize `num_points` while strictly enforcing the geometric constraint. Solutions violating the constraint should receive a heavily penalized (or zero) fitness.
    *   **Genetic Operators**: Design mutation (add/remove/perturb points, apply symmetry operations) and crossover (combine sets from parents) operations that are suitable for integer vectors.

GEOMETRIC INSIGHTS & MATHEMATICAL FOUNDATIONS:
1.  **Constraint Interpretation**: The core constraint $\max_{i} \|p_i\|_2 \le \min_{i \neq j} \|p_i - p_j\|_2$ means that the squared L2 norm of any point from the origin (let $R^2 = \max \|p_i\|_2^2$) must be less than or equal to the squared L2 distance between any two distinct points in the set. This is a very strong condition, implying that points must be relatively "close" to the origin but "far" from each other.
2.  **Homogeneous Norms**: Optimal solutions for similar packing problems often consist of points all having the *same* squared L2 norm. If all points $p \in S$ have $\|p\|_2^2 = R^2$, the condition simplifies to $R^2 \le \min_{i \neq j} \|p_i - p_j\|_2^2$. This is a common pattern in "constant norm codes" or "spherical codes" on lattices.
3.  **Lattice Structures in $\mathbb{Z}^{11}$**:
    *   **D_11 Lattice**: Points in $\mathbb{Z}^{11}$ where the sum of coordinates is even. The minimal non-zero squared L2 norm in D_11 is 2 (e.g., $(\pm 1, \pm 1, 0, ..., 0)$). Consider points from this lattice.
    *   **Candidate Point Types**: Focus on integer vectors with small sums of squares (i.e., small squared L2 norms).
        *   **Squared Norm 1**: Points like $(\pm 1, 0, ..., 0)$. There are $2 \times 11 = 22$ such points. For this set, $\max \|p_i\|_2^2 = 1$, $\min \|p_i - p_j\|_2^2 = \|(1,0,..)-(-1,0,..)\|_2^2 = 4$. Condition $1 \le 4$ holds. This forms a valid set of 22 points.
        *   **Squared Norm 2**: Points like $(\pm 1, \pm 1, 0, ..., 0)$. There are $2^2 \binom{11}{2} = 220$ such points. For this set, $\max \|p_i\|_2^2 = 2$. The minimum pairwise squared distance is 2 (e.g., between $(1,1,0,..)$ and $(1,0,1,..)$ is $\|(0,1,-1,..)\|_2^2 = 2$). Condition $2 \le 2$ holds. This forms a valid set of 220 points.
        *   *Crucial Note*: Merging sets of points with different squared norms (e.g., points of norm 1 and points of norm 2) might easily violate the condition. For instance, if you combine a point from the norm 1 set, e.g., $(1,0,..,0)$, and a point from the norm 2 set, e.g., $(1,1,0,..,0)$, the maximum squared norm of the combined set becomes 2. However, the squared distance between these two points is $\|(0,1,0,..)\|_2^2 = 1$. Since $2 \not\le 1$, such a combined set is invalid. This strongly suggests that the optimal solution might consist of points all having the same squared L2 norm.
4.  **Symmetry of the space**: The 11-dimensional integer lattice exhibits significant symmetries under permutation of coordinates and sign changes. Any successful construction likely leverages these symmetries to efficiently generate and evaluate candidate sets.

**Recommended implementation patterns**:
1.  **NumPy for Vectorized Operations**: Use `numpy` extensively for all vector and matrix operations, especially for calculating L2 norms and distances, to maximize performance.
2.  **Efficient Distance Checking**:
    *   For sets up to a few hundred points, a brute-force $O(N^2)$ check for minimum pairwise distance might be acceptable.
    *   For larger sets or in iterative algorithms, `scipy.spatial.KDTree` can significantly speed up nearest neighbor searches. You can build a KDTree from the current set of points and query it for candidate points (`kdtree.query(point, k=2)` to find the two closest points to a candidate, one of which will be `point` itself if it's already in the set).
3.  **Numba JIT Compilation**: Apply `@numba.jit(nopython=True)` to performance-critical functions (e.g., the constraint checker, candidate point generator, fitness function in EAs) to achieve near C-like execution speeds.
4.  **Candidate Point Generation Utilities**: Implement helper functions:
    *   `generate_permutations_and_signs(base_vector)`: Takes a vector (e.g., `(1,1,0,0,0,0,0,0,0,0,0)`) and returns a list of all unique vectors generated by permuting its non-zero elements and applying all possible sign combinations.
    *   `generate_points_up_to_sq_norm(d, max_sq_norm)`: Recursively or iteratively generates all unique integer vectors in `d` dimensions whose squared L2 norm does not exceed `max_sq_norm`. This can be very slow for large `d` or `max_sq_norm` and should be used cautiously.
5.  **Data Structures**: Store points as `numpy.ndarray` objects. When checking for uniqueness or membership in a set, convert them to `tuple`s (e.g., `set(tuple(p) for p in points_list)`). Convert back to `np.ndarray` for numerical operations.
6.  **Reproducibility**: Ensure `numpy.random.seed(42)` (or similar) is set if any stochastic elements are used.

# PROMPT-BLOCK-END
