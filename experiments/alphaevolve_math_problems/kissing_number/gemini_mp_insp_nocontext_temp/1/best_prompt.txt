SETTING:
You are an expert in high-dimensional geometry, lattice theory, and combinatorial optimization, specializing in sphere packing and coding theory problems.
Your task is to devise a computational strategy and generate a set of points that provides a new state-of-the-art lower bound for a specific variant of the kissing number problem in 11 dimensions.

PROBLEM CONTEXT:
Your goal is to find the largest possible set of points $S \subset \mathbb{Z}^{11}$ (points with 11 integer coordinates) that satisfies the following geometric constraint: the maximum L2 norm of any point from the origin must be less than or equal to the minimum pairwise L2 distance between any two distinct points in the set.

- **Target**: Beat the AlphaEvolve benchmark of **num_points = 593**.
- **Constraint**: For the set of points $S = \{p_1, p_2, ..., p_k\}$ where $p_i \in \mathbb{Z}^{11}$:
  $$\max_{i} \|p_i\|_2 \le \min_{i \neq j} \|p_i - p_j\|_2$$
- **Objective**: Maximize the cardinality of the set, $k = |S|$.

PERFORMANCE METRICS:
1.  **num_points**: The number of points in the final set $S$. **This is the primary objective to maximize.**
2.  **benchmark_ratio**: Your `num_points` / 593. The goal is to achieve a ratio > 1.0.
3.  **eval_time**: The total wall-clock time in seconds to generate the solution.

COMPUTATIONAL RESOURCES & IMPLEMENTATION GUIDELINES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Optimization**: `deap` (evolutionary algorithms), `platypus` (multi-objective optimization)
- **Geometric computing**: `shapely` (geometric operations), `rtree` (spatial indexing), `scipy.spatial` (KDTree, Voronoi)
- **Constraint programming**: `python-constraint`, `ortools` (Google OR-Tools)
- **Physics simulation**: `pymunk` (2D physics), `pybullet` (physics engine)
- **Performance**: `cython`, `joblib` (parallelization), 'numba' (JIT)

TECHNICAL REQUIREMENTS:
- **Determinism & Reproducibility**: Your solution must be fully reproducible. If you use any stochastic algorithms (like simulated annealing or genetic algorithms), you **must use a fixed random seed** (e.g., `numpy.random.seed(42)`).
- **Efficiency**: While secondary to correctness and the number of points, your algorithm should be reasonably efficient. Avoid brute-force searches over the entire $\mathbb{Z}^{11}$ lattice, which is computationally infeasible.

# PROMPT-BLOCK-START

OPTIMIZATION STRATEGIES TO CONSIDER:
- **Greedy Construction with Symmetry**:
    - Start with a small, valid set of points (e.g., basis vectors and their negatives, or specific lattice points with small norms). The origin $(0, \dots, 0)$ should not be included in any set with more than one point, as its inclusion would violate the condition for distinct points.
    - Iteratively add new integer points to the set, ensuring the geometric constraint remains satisfied.
    - Prioritize adding points that are "close" to the origin (small L2 norm) but "far" from existing points (large minimum pairwise distance).
    - **Exploit symmetries**: If a point $p = (x_1, \dots, x_{11})$ is in the set, then points generated by permuting its coordinates and changing their signs (e.g., $(\pm x_{\sigma(1)}, \dots, \pm x_{\sigma(11)})$) are often also valid candidates. This can rapidly expand a small set of "seed" points into a much larger, symmetric set.
- **Lattice-based Search**:
    - The problem involves integer coordinates, suggesting a strong connection to integer lattices. Consider points from known dense lattices or sublattices of $\mathbb{Z}^{11}$ (e.g., the $D_{11}$ lattice where the sum of coordinates is even, or the $A_{11}$ lattice).
    - Systematically search for integer points within a specific L2 norm bound, filtering for those that satisfy the constraint. This can involve iterating over partitions of an integer $N$ into 11 squares to find points with $\|p\|_2^2 = N$.
- **Evolutionary Algorithms (EA)**:
    - Utilize libraries like `deap`. A "chromosome" could represent a set of points.
    - Define a fitness function that primarily maximizes `num_points`, and secondarily minimizes `max_norm` (to keep the set "tight" and potentially allow more points within the radius constraint).
    - Design mutation operators (e.g., add a new valid point, remove a point, perturb a point's coordinates while maintaining integer values) and crossover operators (e.g., combine subsets of points from two parent solutions).
    - Crucially, ensure all generated points maintain integer coordinates and satisfy the core geometric constraint.
- **Iterative Refinement / Local Search**: Start with a reasonably good set (perhaps from a greedy or lattice-based construction) and try to improve it by adding, removing, or slightly modifying points while maintaining validity. This could involve trying to replace a point with a "better" one (e.g., one with a smaller norm that still satisfies distances).

GEOMETRIC INSIGHTS & MATHEMATICAL FOUNDATIONS:
- **Squared Euclidean Norms for Efficiency**: The constraint $\max_{i} \|p_i\|_2 \le \min_{i \neq j} \|p_i - p_j\|_2$ can be more efficiently evaluated using squared L2 norms to avoid computationally expensive square root operations until the final comparison. Let $R^2 = \max_{i} \|p_i\|_2^2$ and $D^2 = \min_{i \neq j} \|p_i - p_j\|_2^2$. The condition is equivalent to $R^2 \le D^2$. Since all coordinates are integers, all squared norms and squared distances will also be integers, allowing for exact comparisons.
- **Sphere Packing Analogy**: This problem is a variant of the sphere packing problem. If we consider open spheres of radius $r = R/2$ centered at each point $p_i$, the condition $R \le D$ implies that these spheres are disjoint. All points $p_i$ (and thus their associated spheres) are contained within a larger sphere of radius $R$ centered at the origin. The goal is to maximize the number of such disjoint spheres within a given bounding sphere.
- **Origin Exclusion**: The origin $(0,0,\dots,0)$ cannot be part of any valid set $S$ with $|S| \ge 2$. If $0 \in S$, then $\max \|p_i\|_2 \ge 0$. For the condition to hold, $\min \|p_i - p_j\|_2$ must also be 0, which implies two points are identical, contradicting the definition of a set of distinct points. Therefore, all points $p_i \in S$ must be non-zero.
- **Lattice Structure and Symmetries**: Since points are in $\mathbb{Z}^{11}$, the problem leverages the discrete nature of integer lattices. Exploiting the symmetries of the hypercube lattice (permutations of coordinates, sign changes) is crucial for efficiently generating candidate points and expanding valid sets. For example, if $(1,1,0,\dots,0)$ is a valid point, then all $11 \times 10 / 2 = 55$ permutations of $(\pm 1, \pm 1, 0, \dots, 0)$ are also candidates.

**Recommended implementation patterns**:
- **Constraint Validation Function**: Implement a robust and efficient helper function, e.g., `is_valid_set(points: np.ndarray) -> bool`, that takes a set of points (as a NumPy array) and checks the geometric constraint. This function should compute squared L2 norms and pairwise squared Euclidean distances.
- **Efficient Distance Calculation**:
    - Use `np.sum(p**2)` or `np.linalg.norm(p, ord=2)**2` for squared L2 norms of individual points.
    - For pairwise squared distances between all points in a set, `scipy.spatial.distance.pdist(points, metric='sqeuclidean')` is highly efficient, followed by `np.min` to find $D^2$.
- **Spatial Indexing**: For larger sets of points, `scipy.spatial.KDTree` can significantly accelerate the search for nearest neighbors when adding new candidate points, avoiding full pairwise distance calculations. This is particularly useful in greedy construction.
- **Performance Optimization with Numba**: For critical loops or the `is_valid_set` function, consider using `numba.jit` to compile Python code to machine code for significant speedups, especially in high dimensions.
- **Generating Candidate Points**:
    - To systematically generate integer points $(x_1, \dots, x_{11})$ with increasing squared L2 norm $\sum x_i^2 = N$, follow these steps for a given "seed" vector (e.g., representing a specific squared norm shell):
        1.  **Form a canonical seed vector**: Start with a tuple of non-negative integers, e.g., `(2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0)`. Ensure this tuple has `d=11` elements, with explicit zeros for the remaining dimensions.
        2.  **Generate unique permutations**: From this canonical seed vector, generate all unique permutations of its elements. For example, `(2,1,1,0,...)` can be permuted to `(1,2,1,0,...)`, etc. `itertools.permutations` can be used, but to handle repeated elements efficiently and avoid duplicates, consider using `collections.Counter` with a recursive approach or `sympy.utilities.iterables.multiset_permutations`. Alternatively, convert the permutations to a `set` of tuples to ensure uniqueness.
        3.  **Apply sign changes**: For each unique permuted vector (which is now a full 11-dimensional tuple of integers), generate all possible sign combinations for its *non-zero* elements. For example, if `p = (2, 1, 1, 0, ...)`, then `(-2, 1, 1, 0, ...)`, `(2, -1, 1, 0, ...)`, etc., are also candidates. Use `itertools.product([-1, 1], repeat=count_of_non_zeros)` to generate sign combinations.
    - **Crucial Note on Data Types**: When constructing points, ensure all coordinates are concrete integers (e.g., `0`, `1`, `-1`, `2`, etc.) before performing any arithmetic operations (like multiplication by signs or norm calculations). Avoid using placeholder values like `None` in arrays or tuples that will later be treated as numerical data, as this can lead to `TypeError`s.
    - Store points in a `set` of `tuple`s during construction for efficient uniqueness checks and fast membership testing, then convert to `np.ndarray` for numerical computations.
- **Reproducibility**: Ensure `numpy.random.seed(42)` (or similar) is used if any stochastic elements are introduced (e.g., in evolutionary algorithms or randomized searches).

# PROMPT-BLOCK-END
