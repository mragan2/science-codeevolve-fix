SETTING:
You are an expert computational geometer and optimization specialist focusing on circle packing problems.
Your task is to evolve a constructor function that generates an optimal arrangement of exactly 32 non-overlapping circles within a unit square [0,1] × [0,1], maximizing the sum of their radii.

PROBLEM CONTEXT:
- Target: Beat the AlphaEvolve benchmark of sum_radii = 2.937944526205518
- Constraint: All circles must be fully contained within the unit square with no overlaps
- Mathematical formulation: For circle i at position (xi, yi) with radius ri:
  * Containment: ri ≤ xi ≤ 1-ri and ri ≤ yi ≤ 1-ri
  * Non-overlap: √[(xi-xj)² + (yi-yj)²] ≥ ri + rj for all i≠j
  * Objective: maximize Σri subject to above constraints

COMPUTATIONAL RESOURCES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Optimization**: `deap` (evolutionary algorithms), `platypus` (multi-objective optimization)
- **Geometric computing**: `shapely` (geometric operations), `rtree` (spatial indexing), `scipy.spatial` (KDTree, Voronoi)
- **Constraint programming**: `python-constraint`, `ortools` (Google OR-Tools)
- **Physics simulation**: `pymunk` (2D physics), `pybullet` (physics engine)
- **Performance**: `cython`, `joblib` (parallelization)

PERFORMANCE METRICS:
1. **sum_radii**: Total sum of all 32 circle radii (PRIMARY OBJECTIVE - maximize)
2. **benchmark_ratio**: sum_radii / 2.937944526205518 (progress toward beating benchmark)  
3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)

TECHNICAL REQUIREMENTS:
- **Determinism**: Use fixed random seeds if employing stochastic methods for reproducibility
- **Error handling**: Graceful handling of optimization failures or infeasible configurations
- **Memory efficiency**: Avoid excessive memory allocation for distance matrix computations
- **Scalability**: Design with potential extension to different circle counts in mind

# PROMPT-BLOCK-START

**Recommended implementation patterns:**
1.  **State Representation:** Represent the state of all circles as a single 1D NumPy array `x = [x1, y1, r1, x2, y2, r2, ..., xN, yN, rN]`. This format is compatible with `scipy.optimize.minimize`.
2.  **Objective Function:** Define an objective function `f(x)` that returns the negative sum of radii (since `scipy.optimize.minimize` performs minimization). Ensure radii are positive.
3.  **Constraint Functions:**
    *   **Containment Constraints:** For each circle `i`, define inequality constraints `g_containment(x) >= 0` such that `xi - ri >= 0`, `1 - xi - ri >= 0`, `yi - ri >= 0`, `1 - yi - ri >= 0`.
    *   **Non-overlap Constraints:** For each unique pair of circles `(i, j)`, define an inequality constraint `g_non_overlap(x) >= 0` such that `(xi-xj)² + (yi-yj)² - (ri+rj)² >= 0`. This is equivalent to `distance² >= (ri+rj)²`.
    *   **Radius Positivity:** Ensure `ri > 0` for all circles. This can be handled by bounds or additional constraints.
4.  **Scipy.optimize.minimize:** Use `scipy.optimize.minimize` as the core optimization solver. It allows defining bounds and various types of constraints.

OPTIMIZATION STRATEGIES TO CONSIDER:
1.  **Local Optimization (Gradient-based/Gradient-free):**
    *   **`scipy.optimize.minimize`:** This is the primary tool.
        *   **Method:** Consider `SLSQP` or `trust-constr` which can handle bounds and general inequality constraints. `SLSQP` is often a good default for constrained problems.
        *   **Initial Guess:** The choice of initial `x0` is critical due to the non-convex nature of the problem.
            *   **Random Placement:** Start with random `(x,y)` coordinates and very small `r`.
            *   **Grid-based Placement:** Place circles in a grid-like pattern with small initial radii.
            *   **Small Radii:** Begin with all radii very small and let the optimizer expand them.
    *   **Multiple Restarts:** Run the optimization from several different random initial guesses to increase the chance of finding a better local optimum, or even the global optimum.
2.  **Iterative Refinement:**
    *   Start with a simpler sub-problem (e.g., fewer circles, or fixed small radii and optimize positions, then optimize radii).
    *   Gradually increase the complexity or number of circles.
3.  **Metaheuristics (Advanced):** While `scipy.optimize` should be the first approach, for very challenging non-convex landscapes, methods from `deap` (evolutionary algorithms) or `platypus` (multi-objective, but can be adapted) could be considered for global search, though they are generally slower.

GEOMETRIC INSIGHTS & MATHEMATICAL FOUNDATIONS:
1.  **Non-convexity:** Circle packing is a notoriously difficult non-convex optimization problem. It has many local optima, meaning a local optimizer might get stuck far from the global best.
2.  **Constraint Formulation:**
    *   **Containment:** The constraints `r <= x <= 1-r` and `r <= y <= 1-r` correctly define containment.
    *   **Non-overlap:** The constraint `√[(xi-xj)² + (yi-yj)²] ≥ ri + rj` is best squared to avoid square roots in the objective/constraint functions, leading to `(xi-xj)² + (yi-yj)² ≥ (ri+rj)²`. This is a smooth, differentiable inequality.
3.  **Symmetry:** Optimal packings for specific numbers of circles often exhibit rotational or translational symmetry. While not strictly required to implement, recognizing this can sometimes simplify initial guesses or provide hints for verifying solutions.
4.  **Efficient Distance Calculation:** For all-pairs distance calculations, `scipy.spatial.distance.pdist` or `cdist` can be more efficient than nested loops, especially for larger N, though for N=32, direct calculation is also feasible.

VALIDATION FRAMEWORK:
1.  **Helper Functions:**
    *   `is_contained(x, y, r)`: Checks if a single circle is within `[0,1]x[0,1]`.
    *   `has_overlap(x1, y1, r1, x2, y2, r2)`: Checks if two circles overlap.
    *   `validate_solution(circles_array)`: A comprehensive function that iterates through all circles and pairs to ensure all containment and non-overlap constraints are met. It should return `True` if valid, `False` otherwise, and optionally print violated constraints.
2.  **Post-Optimization Check:** After the optimization completes, always run `validate_solution` on the returned `circles` array to confirm the solution is feasible.
3.  **Radii Check:** Ensure all radii are strictly positive. An optimizer might reduce a radius to zero if not properly constrained or initialized.
4.  **Visualization (Optional but Recommended):** Use `matplotlib.pyplot` to plot the circles within the unit square to visually inspect the packing. This is invaluable for debugging and understanding the solution quality.

# PROMPT-BLOCK-END
    
