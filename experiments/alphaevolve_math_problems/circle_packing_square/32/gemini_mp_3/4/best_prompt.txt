SETTING:
You are an expert computational geometer and optimization specialist focusing on circle packing problems.
Your task is to evolve a constructor function that generates an optimal arrangement of exactly 32 non-overlapping circles within a unit square [0,1] × [0,1], maximizing the sum of their radii.

PROBLEM CONTEXT:
- Target: Beat the AlphaEvolve benchmark of sum_radii = 2.937944526205518
- Constraint: All circles must be fully contained within the unit square with no overlaps
- Mathematical formulation: For circle i at position (xi, yi) with radius ri:
  * Containment: ri ≤ xi ≤ 1-ri and ri ≤ yi ≤ 1-ri
  * Non-overlap: √[(xi-xj)² + (yi-yj)²] ≥ ri + rj for all i≠j
  * Objective: maximize Σri subject to above constraints

COMPUTATIONAL RESOURCES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Optimization**: `deap` (evolutionary algorithms), `platypus` (multi-objective optimization)
- **Geometric computing**: `shapely` (geometric operations), `rtree` (spatial indexing), `scipy.spatial` (KDTree, Voronoi)
- **Constraint programming**: `python-constraint`, `ortools` (Google OR-Tools)
- **Physics simulation**: `pymunk` (2D physics), `pybullet` (physics engine)
- **Performance**: `cython`, `joblib` (parallelization)

PERFORMANCE METRICS:
1. **sum_radii**: Total sum of all 32 circle radii (PRIMARY OBJECTIVE - maximize)
2. **benchmark_ratio**: sum_radii / 2.937944526205518 (progress toward beating benchmark)  
3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)

TECHNICAL REQUIREMENTS:
- **Determinism**: Use fixed random seeds if employing stochastic methods for reproducibility
- **Error handling**: Graceful handling of optimization failures or infeasible configurations
- **Memory efficiency**: Avoid excessive memory allocation for distance matrix computations
- **Scalability**: Design with potential extension to different circle counts in mind

# PROMPT-BLOCK-START

**Recommended implementation patterns:**
*   **Circle Representation**: Represent each circle as a tuple `(x, y, r)` or a row in a `(N, 3)` NumPy array, where `x`, `y` are center coordinates and `r` is the radius.
*   **Objective Function**: Define a function that takes the `(N, 3)` array of circles and returns the sum of radii (to be maximized). For optimizers that minimize, return the negative sum of radii.
*   **Constraint Functions**: Define functions that return constraint violations. For `scipy.optimize.minimize`, these can be structured as `NonlinearConstraint` objects, where `g(x) >= 0` for inequality constraints.
*   **Initial Configuration**: The choice of initial circle positions and radii is critical due to the non-convex nature of the problem.
    *   Random placement with small initial radii.
    *   A grid-based initial placement.
    *   Using a physics-based simulation (e.g., `pymunk`) to "relax" an initial configuration, allowing circles to repel each other and expand until they touch boundaries or other circles.
*   **Vectorization**: Leverage NumPy's vectorized operations for distance calculations and constraint checks to improve performance, especially when dealing with all-pairs interactions.

OPTIMIZATION STRATEGIES TO CONSIDER:
The circle packing problem is a challenging non-convex optimization problem with many local optima. A robust approach typically involves a combination of global and local search.

1.  **Local Optimization (e.g., using `scipy.optimize.minimize`):**
    *   **Method**: `SLSQP` (Sequential Least Squares Programming) is often suitable as it handles bounds and both equality and inequality constraints. `L-BFGS-B` can be used if constraints are incorporated into the objective as penalties.
    *   **Objective**: Minimize the negative sum of radii: `f(circles) = -np.sum(circles[:, 2])`.
    *   **Bounds**: Radii `r` must be positive. Center coordinates `x, y` must be between `r` and `1-r`.
    *   **Constraints**:
        *   **Containment**: `r_i <= x_i <= 1-r_i` and `r_i <= y_i <= 1-r_i`. These can be formulated as `x_i - r_i >= 0`, `1 - r_i - x_i >= 0`, etc.
        *   **Non-overlap**: For each pair `(i, j)` with `i < j`: `(x_i - x_j)² + (y_i - y_j)² - (r_i + r_j)² >= 0`. To avoid `sqrt`, work with squared distances.
    *   **Warm-starting**: Run local optimization from multiple different initial configurations to explore different local optima.

2.  **Global Optimization / Metaheuristics:**
    *   **Evolutionary Algorithms (e.g., `deap`, `platypus`):** Genetic Algorithms (GA) or multi-objective algorithms like NSGA-II can be effective at exploring the search space and finding promising regions. They can naturally handle constraints through penalty functions or specialized operators.
    *   **Simulated Annealing (`scipy.optimize.dual_annealing`):** Can escape local minima by occasionally accepting worse solutions, gradually reducing this tendency.
    *   **Basin-hopping (`scipy.optimize.basinhopping`):** Combines a global stepping algorithm with local minimization to find global minima.
    *   **Hybrid Approaches**: Often, a metaheuristic is used to find a good initial solution, which is then refined by a local gradient-based optimizer.

3.  **Constraint Handling**:
    *   **Penalty Methods**: Add a penalty term to the objective function for each violated constraint. The penalty magnitude increases with the violation severity. This converts a constrained problem into an unconstrained one (or one with simpler bounds).
    *   **Augmented Lagrangian Methods**: More sophisticated penalty methods that can achieve exact solutions.
    *   **Direct Constraint Handling**: Using optimizers like `SLSQP` that directly incorporate constraints into their formulation.

GEOMETRIC INSIGHTS & MATHEMATICAL FOUNDATIONS:
*   **NP-Hardness**: Circle packing in a square is a known NP-hard problem. There are no known analytical solutions for arbitrary N, especially N=32. Optimal solutions are typically found through numerical optimization.
*   **Non-Convexity**: The problem's search space is highly non-convex, meaning there are many local optima. This necessitates global optimization strategies or multiple restarts of local optimizers.
*   **Objective Function**: Maximizing the sum of radii naturally encourages circles to expand and pack as densely as possible.
*   **Constraints**:
    *   **Containment**: `ri <= xi <= 1-ri` and `ri <= yi <= 1-ri`. This also implies `ri <= 0.5`.
    *   **Non-overlap**: `(xi-xj)² + (yi-yj)² >= (ri + rj)²` for all `i≠j`. This is the core interaction constraint.
*   **Contact Graph**: Optimal packings often form a "contact graph" where circles touch each other and/or the boundaries. The structure of this graph can sometimes provide insights, but for N=32, it's likely complex and irregular.
*   **Symmetry**: While some small N have symmetric optimal packings, N=32 is large enough that the optimal packing might be irregular. Do not overly rely on symmetry for the initial configuration.

VALIDATION FRAMEWORK:
A robust validation function is crucial to verify the correctness of any generated solution.
```python
import numpy as np

def validate_packing(circles: np.ndarray, epsilon: float = 1e-6) -> tuple[bool, float, dict]:
    """
    Validates a given circle packing configuration and calculates the sum of radii.

    Args:
        circles: np.array of shape (N, 3), where each row is (x, y, r).
        epsilon: Tolerance for floating-point comparisons in constraints.

    Returns:
        A tuple: (is_valid, sum_radii, violations)
        is_valid: True if all constraints are met, False otherwise.
        sum_radii: The total sum of all circle radii.
        violations: A dictionary detailing any constraint violations.
    """
    n_circles = circles.shape[0]
    x, y, r = circles[:, 0], circles[:, 1], circles[:, 2]

    violations = {
        "radius_non_positive": [],
        "containment_x_min": [],
        "containment_x_max": [],
        "containment_y_min": [],
        "containment_y_max": [],
        "overlap": []
    }

    # 1. Check for non-positive radii (shouldn't happen with maximization objective but good for robustness)
    for i in range(n_circles):
        if r[i] < -epsilon: # Allow very small negative due to float precision
            violations["radius_non_positive"].append(i)

    # 2. Check containment within unit square [0,1]x[0,1]
    for i in range(n_circles):
        if x[i] - r[i] < -epsilon:
            violations["containment_x_min"].append(i)
        if x[i] + r[i] > 1 + epsilon:
            violations["containment_x_max"].append(i)
        if y[i] - r[i] < -epsilon:
            violations["containment_y_min"].append(i)
        if y[i] + r[i] > 1 + epsilon:
            violations["containment_y_max"].append(i)
        
        # Ensure r is not excessively large (max 0.5)
        if r[i] > 0.5 + epsilon:
            violations["containment_x_max"].append(i) # or a new specific violation

    # 3. Check for non-overlap between circles
    for i in range(n_circles):
        for j in range(i + 1, n_circles): # Check each pair once
            dist_sq = (x[i] - x[j])**2 + (y[i] - y[j])**2
            min_dist_sq = (r[i] + r[j])**2
            if dist_sq < min_dist_sq - epsilon:
                violations["overlap"].append((i, j, np.sqrt(min_dist_sq) - np.sqrt(dist_sq))) # store overlap amount

    is_valid = all(not v for v in violations.values())
    sum_radii = np.sum(r) if all(val >= -epsilon for val in r) else 0.0 # Don't sum negative radii

    return is_valid, sum_radii, violations

```
The `validate_packing` function should be used to score candidate solutions and verify the final output. The `epsilon` parameter is crucial for robust floating-point comparisons.

# PROMPT-BLOCK-END
    
