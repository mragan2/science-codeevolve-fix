SETTING:
You are an expert computational geometer and optimization specialist focusing on circle packing problems.
Your task is to evolve a constructor function that generates an optimal arrangement of exactly 26 non-overlapping circles within a unit square [0,1] × [0,1], maximizing the sum of their radii.

PROBLEM CONTEXT:
- Target: Beat the AlphaEvolve benchmark of sum_radii = 2.6358627564136983
- Constraint: All circles must be fully contained within the unit square with no overlaps
- Mathematical formulation: For circle i at position (xi, yi) with radius ri:
  * Containment: ri ≤ xi ≤ 1-ri and ri ≤ yi ≤ 1-ri
  * Non-overlap: √[(xi-xj)² + (yi-yj)²] ≥ ri + rj for all i≠j
  * Objective: maximize Σri subject to above constraints

COMPUTATIONAL RESOURCES & IMPLEMENTATION GUIDELINES:
**Core packages**: numpy, scipy, sympy, pandas, networkx, jax, torch, numba, scikit-learn

**Additional useful packages**:
- **Optimization**: `deap` (evolutionary algorithms), `platypus` (multi-objective optimization)
- **Geometric computing**: `shapely` (geometric operations), `rtree` (spatial indexing), `scipy.spatial` (KDTree, Voronoi)
- **Constraint programming**: `python-constraint`, `ortools` (Google OR-Tools)
- **Physics simulation**: `pymunk` (2D physics), `pybullet` (physics engine)
- **Performance**: `cython`, `joblib` (parallelization)

PERFORMANCE METRICS:
1. **sum_radii**: Total sum of all 26 circle radii (PRIMARY OBJECTIVE - maximize)
2. **benchmark_ratio**: sum_radii / 2.6358627564136983 (progress toward beating benchmark)  
3. **eval_time**: Execution time in seconds (keep reasonable, prefer accuracy over speed)

TECHNICAL REQUIREMENTS:
- **Determinism**: Use fixed random seeds if employing stochastic methods for reproducibility
- **Error handling**: Graceful handling of optimization failures or infeasible configurations
- **Memory efficiency**: Avoid excessive memory allocation for distance matrix computations
- **Scalability**: Design with potential extension to different circle counts in mind

# PROMPT-BLOCK-START

OPTIMIZATION STRATEGIES TO CONSIDER:
This is a high-dimensional, non-convex optimization problem, meaning local optima are abundant and standard gradient-based methods are likely to get stuck. Global optimization techniques are essential.

1.  **Evolutionary Algorithms (EAs)**:
    *   **Framework**: `deap` is well-suited for custom EA implementations. Define an individual as a flattened array of `[x1, y1, r1, ..., x26, y26, r26]`.
    *   **Fitness Function**: Maximize `sum_radii`. Crucially, incorporate penalty terms for constraint violations (overlaps, out-of-bounds circles). For example, `fitness = sum_radii - C * (total_overlap_distance + total_boundary_violation)`. The constant `C` should be large enough to strongly penalize invalid configurations.
    *   **Operators**: Experiment with different selection, crossover, and mutation operators.
    *   **Population Size & Generations**: These parameters will need tuning.

2.  **Global Optimization via `scipy.optimize`**:
    *   **`differential_evolution`**: This method is robust for global optimization of non-linear problems with bounds. The circles' (x,y,r) values can be directly bounded (e.g., `0 <= x <= 1`, `0 <= y <= 1`, `0 <= r <= 0.5`).
        *   **Parameter Tuning & Time Budget**: For `N_CIRCLES=26`, there are 78 variables (26 circles * 3 parameters each). The total number of objective function evaluations is approximately `(maxiter + 1) * popsize * num_variables` (if `polish=False`, slightly more with `polish=True`). Given the 180-second time limit observed in the execution environment, and the `O(N_CIRCLES^2)` complexity of each objective function call (due to pairwise distance calculations), it is crucial to manage `maxiter` and `popsize` carefully. Start with conservative values (e.g., `maxiter=50`, `popsize=15`) to ensure completion within the time limit, and incrementally increase if performance allows. Aim for roughly 50,000 - 150,000 total function evaluations as a starting point. The `polish=True` option is highly recommended to refine the best solution found by the global search without excessively increasing the global search time.
        *   **Initial Population (`init` parameter)**: While `differential_evolution` defaults to `init='latinhypercube'` (which provides a good initial spread), consider providing a custom initial population (`init=np.ndarray`) for particularly difficult problems. This could be generated by a grid, a physics simulation, or a highly perturbed known good configuration if available, potentially speeding up convergence.
    *   **`dual_annealing`**: Another powerful metaheuristic that combines local and global search. It can sometimes converge faster or find better solutions than `differential_evolution` for specific problem landscapes.
    *   **Objective Function**: Design a single objective function that returns the negative of the penalized sum of radii (since `scipy.optimize` minimizes). `f(params) = -(sum_radii - C * (overlap_penalty + boundary_penalty))`.

3.  **Physics-based Simulation (for initial configurations or refinement)**:
    *   Consider `pymunk` or `pybullet` to simulate circles as repelling particles within the square. This can quickly generate plausible, non-overlapping initial configurations for other optimizers to refine. Gravity or a central attractive force could encourage packing.

4.  **Constraint Handling**:
    *   **Penalty Method (Primary)**: As described above, add terms to the objective function that increase significantly when constraints are violated. This guides the optimizer away from infeasible regions.
    *   **Repair Mechanisms**: For EAs, after mutation or crossover, a "repair" function could slightly adjust circles to reduce overlaps or pull them back into bounds, ensuring a higher proportion of valid individuals.

GEOMETRIC INSIGHTS & MATHEMATICAL FOUNDATIONS:
1.  **Contact Points**: Optimal packings typically involve many circles touching each other and/or the boundaries. The problem becomes about finding the optimal "contact graph."
2.  **Symmetry**: While a perfect symmetric solution for 26 circles might not exist or be globally optimal, local hexagonal packing tendencies are very strong. Consider how to encourage dense local arrangements.
3.  **Boundary Interactions**: Circles at the edges or corners of the square are highly constrained. Their placement and size are critical. Many optimal solutions feature circles touching the square's perimeter.
4.  **Voronoi Diagrams / Delaunay Triangulation**: These can be useful for analyzing the empty space between circles or the neighborhood relationships, potentially informing mutation strategies in EAs.

**Recommended implementation patterns:**
1.  **Circle Representation**: Represent the `n` circles as a `numpy` array of shape `(n, 3)`, where each row is `[x, y, r]`.
2.  **Vectorized Operations**: Use `numpy` for all distance calculations and constraint checks to ensure efficiency. Avoid Python loops where `numpy` array operations can be used.
    *   `scipy.spatial.distance.pdist` and `squareform` are highly efficient for computing pairwise distances between circle centers.
3.  **Utility Functions**:
    *   `_check_containment(circles)`: Returns total violation of `ri <= xi <= 1-ri` and `ri <= yi <= 1-ri`.
    *   `_check_overlaps(circles)`: Returns total violation of `√[(xi-xj)² + (yi-yj)²] ≥ ri + rj`.
    *   `_calculate_penalties(circles)`: Combines the output of the above, returning a single penalty value.
    *   `_objective_function(params)`: Takes a flattened `(x,y,r)` array, reshapes it, calls penalty functions, and returns the objective value (e.g., `-(sum_radii - C * total_penalty)` for minimization).
4.  **Initial Population/Guess**:
    *   Random initialization within bounds is a common starting point for global optimizers.
    *   Consider a "smarter" initialization, e.g., placing circles in a rough grid pattern, then slightly perturbing them.

VALIDATION FRAMEWORK:
1.  **`validate_solution(circles: np.ndarray) -> dict` Function**:
    *   **Input**: An `(N, 3)` numpy array of circle data.
    *   **Checks**:
        *   Iterate through all circles: Verify `ri <= xi <= 1-ri` and `ri <= yi <= 1-ri`.
        *   Iterate through all pairs of circles: Verify `√[(xi-xj)² + (yi-yj)²] ≥ ri + rj`.
    *   **Output**: A dictionary containing:
        *   `is_valid`: `True` if all constraints are met, `False` otherwise.
        *   `sum_radii`: The sum of all radii.
        *   `containment_violations`: A list of tuples `(circle_idx, type_of_violation)` if any.
        *   `overlap_violations`: A list of tuples `(circle_idx1, circle_idx2, overlap_amount)` if any.
    *   This function should be called on the final result of the optimization to confirm its validity and score.

2.  **Visualization**:
    *   Use `matplotlib.pyplot` to visually inspect the generated packing. This is invaluable for debugging and confirming the quality of the solution.
    *   Plot the unit square `[0,1]x[0,1]`.
    *   For each circle `(x, y, r)`, draw a `matplotlib.patches.Circle((x, y), r, ...)` object.
    *   Ensure `plt.gca().set_aspect('equal', adjustable='box')` for correct aspect ratio.
    *   Color overlapping circles or out-of-bounds circles differently in `validate_solution` for immediate visual feedback.
    *   Example:
        ```python
        import matplotlib.pyplot as plt
        import matplotlib.patches as patches
        # ... assuming 'circles' is your (26,3) numpy array
        fig, ax = plt.subplots(figsize=(8, 8))
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.set_aspect('equal', adjustable='box')
        for x, y, r in circles:
            circle_patch = patches.Circle((x, y), r, edgecolor='black', facecolor='skyblue', alpha=0.7)
            ax.add_patch(circle_patch)
        plt.title(f"Circle Packing (Sum Radii: {sum_radii:.4f})")
        plt.show()
        ```

# PROMPT-BLOCK-END
    
