# ===--------------------------------------------------------------------------------------===#
#
# Part of the CodeEvolve Project, under the Apache License v2.0.
# See https://github.com/inter-co/science-codeevolve/blob/main/LICENSE for license information.
# SPDX-License-Identifier: Apache-2.0
#
# ===--------------------------------------------------------------------------------------===#
#
# This file implements the parsing functions for parsing language models responses to
# CodeEvolve's prompts.
#
# ===--------------------------------------------------------------------------------------===#

from typing import Dict, Tuple, List
import re


class SearchAndReplaceError(Exception):
    """Exception raised when a search pattern cannot be found in any evolve block.

    This exception is thrown when applying diff operations if a search pattern
    from a diff block cannot be located within any of the designated evolve blocks
    in the parent code.
    """

    pass


class DiffError(Exception):
    """Exception raised when no diff blocks are found in the diff string.

    This exception is thrown when parsing diff content if no valid diff blocks
    matching the expected format are discovered.
    """

    pass


class EvolveBlockError(Exception):
    """Exception raised when no evolve blocks are found in the parent code.

    This exception is thrown when searching for evolve blocks if no blocks
    matching the expected format are found in the parent code.
    """

    pass


def _sanitize_block_content(text: str, start_marker: str, end_marker: str) -> str:
    """Removes specific start and end marker lines and strips surrounding whitespace.

    This helper function is designed to clean up text blocks, particularly those
    generated by an LLM that might erroneously include surrounding delimiters
    (e.g., '# PROMPT-BLOCK-START'). It checks for the exact presence of the
    start and end markers at the respective ends of the string and removes
    them if found. Finally, it strips any leading or trailing whitespace that
    might have been left behind from the original string or created by the
    marker removal.

    Args:
        text: The input string to sanitize.
        start_marker: The exact prefix string to remove if it exists at the start.
        end_marker: The exact suffix string to remove if it exists at the end.

    Returns:
        The sanitized string, free of the specified markers and surrounding
        whitespace.

    """

    sanitized_text = text
    if sanitized_text.startswith(start_marker):
        sanitized_text = sanitized_text[len(start_marker) :]
    if sanitized_text.endswith(end_marker):
        sanitized_text = sanitized_text[: -len(end_marker)]
    return sanitized_text.strip()


def parse_diff_blocks(
    diff: str, diff_regex: str, start_marker: str, end_marker: str
) -> List[Tuple[str, str]]:
    """Parses and sanitizes diff blocks from a diff string using a regex pattern.

    This function first uses a regular expression to find all occurrences of
    search-and-replace blocks within the input `diff` string. After extracting
    the raw `search` and `replace` content for each block, it systematically
    cleans them using the `_sanitize_block_content` helper function with the
    provided markers.

    The sanitization step removes the specified start and end markers and trims
    surrounding whitespace. This makes the subsequent matching process more
    robust to variations in LLM output.

    Args:
        diff: The full diff string containing one or more search-and-replace
              blocks.
        diff_regex: A regular expression pattern to match the diff blocks. It
                    must contain two capture groups: the first for the search
                    text and the second for the replace text.
        start_marker: The exact string that marks the beginning of a block,
                      used for sanitizing the LLM's output.
        end_marker: The exact string that marks the end of a block, used for
                    sanitizing the LLM's output.

    Returns:
        A list of tuples, where each tuple contains the
        (`sanitized_search_text`, `sanitized_replace_text`).

    Raises:
        DiffError: If no diff blocks matching the regex pattern are found.
    """
    diff_blocks_raw: List[Tuple[str, str]] = re.findall(diff_regex, diff, re.DOTALL)
    if not diff_blocks_raw:
        raise DiffError("No DIFF blocks found.")

    sanitized_blocks: List[Tuple[str, str]] = []
    for search, replace in diff_blocks_raw:
        clean_search = _sanitize_block_content(search.strip(), start_marker, end_marker)
        clean_replace = _sanitize_block_content(replace.strip(), start_marker, end_marker)
        sanitized_blocks.append((clean_search, clean_replace))

    return sanitized_blocks


def find_evolve_block_spans(parent_code: str, evolve_regex: str) -> List[Tuple[int, int]]:
    """Finds the character spans of all evolve blocks in the parent code.

    This function searches for evolve blocks in the parent code using regex
    and returns their start and end positions for later modification.

    Args:
        parent_code: The source code containing evolve blocks to be modified.
        evolve_regex: Regular expression pattern to match evolve blocks. Should
                     contain one capture group for the block content.

    Returns:
        List of tuples where each tuple contains (start_pos, end_pos) character
        indices of evolve block content (excluding markers).

    Raises:
        EvolveBlockError: If no evolve blocks are found in the parent code.
    """
    evolve_spans: List[Tuple[int, int]] = []

    for match in re.finditer(evolve_regex, parent_code, re.DOTALL):
        evolve_spans.append(match.span(1))

    if not evolve_spans:
        raise EvolveBlockError("No EVOLVE blocks found.")

    return evolve_spans


def assign_diffs_to_blocks(
    parent_code: str,
    diff_blocks: List[Tuple[str, str]],
    evolve_spans: List[Tuple[int, int]],
) -> Dict[int, List[int]]:
    """Assigns diff operations to their corresponding evolve blocks.

    This function determines which evolve block each diff operation should be
    applied to by searching for the search text within each block's content.

    Args:
        parent_code: The source code containing evolve blocks.
        diff_blocks: List of (search_text, replace_text) tuples from diff parsing.
        evolve_spans: List of (start_pos, end_pos) tuples for evolve blocks.

    Returns:
        Dictionary mapping evolve block indices to lists of diff block indices
        that should be applied to that block.

    Raises:
        SearchAndReplaceError: If a search pattern cannot be found in any evolve block.
    """

    block_assignments: Dict[int, List[int]] = {i: [] for i in range(len(evolve_spans))}

    for diff_idx, (search_text, _) in enumerate(diff_blocks):
        match_found: bool = False

        for block_idx, (start, end) in enumerate(evolve_spans):
            block_content = parent_code[start:end]

            if search_text in block_content:
                match_found = True
                block_assignments[block_idx].append(diff_idx)
                break

        if not match_found:
            raise SearchAndReplaceError(
                f"Search block not found in any evolve blocks: '{search_text}'"
            )

    return block_assignments


def apply_replacements(
    parent_code: str,
    diff_blocks: List[Tuple[str, str]],
    evolve_spans: List[Tuple[int, int]],
    block_assignments: Dict[int, List[int]],
) -> List[str]:
    """Applies search-and-replace operations to evolve blocks.

    This function performs the actual text replacements within each evolve block
    based on the assigned diff operations, processing them in sequence.

    Args:
        parent_code: The source code containing evolve blocks.
        diff_blocks: List of (search_text, replace_text) tuples.
        evolve_spans: List of (start_pos, end_pos) tuples for evolve blocks.
        block_assignments: Mapping of block indices to diff indices to apply.

    Returns:
        List of modified content strings for each evolve block after applying
        all assigned replacements.
    """
    modified_blocks: List[str] = []

    for block_idx, (start, end) in enumerate(evolve_spans):
        current_content: str = parent_code[start:end]

        for diff_idx in block_assignments[block_idx]:
            search_text, replace_text = diff_blocks[diff_idx]
            current_content = current_content.replace(search_text, replace_text, 1)

        modified_blocks.append(current_content)

    return modified_blocks


def apply_diff(
    parent_code: str,
    diff: str,
    start_marker: str = "# EVOLVE-BLOCK-START",
    end_marker: str = "# EVOLVE-BLOCK-END",
    diff_regex: str = r"<{7}\s*SEARCH\s*\n?(.*?)\n?\s*={7}\s*\n?(.*?)\n?\s*>{7}\s*REPLACE",
) -> str:
    """Applies diff operations to marked blocks in parent code.

    This is the main function that orchestrates the diff application process.
    It dynamically constructs a regex from the start and end markers to find
    the blocks that can be modified (`evolve blocks`). It then parses the diff,
    assigns each change to its corresponding block, applies the replacements,
    and reconstructs the final code.

    Args:
        parent_code: The source code containing the marked blocks to be modified.
        diff: The diff string containing the search-and-replace operations.
        start_marker: The string that marks the beginning of an evolve block.
        end_marker: The string that marks the end of an evolve block.
        diff_regex: Regex pattern to match diff operations. The default handles
                    the "<<<<<<< SEARCH / ======= / >>>>>>> REPLACE" format.
    """

    evolve_regex: str = rf"\s*{re.escape(start_marker)}\s*\n?(.*?)\n?\s*{re.escape(end_marker)}"

    diff_blocks: List[Tuple[str, str]] = parse_diff_blocks(
        diff=diff, diff_regex=diff_regex, start_marker=start_marker, end_marker=end_marker
    )

    evolve_spans: List[Tuple[int, int]] = find_evolve_block_spans(
        parent_code=parent_code, evolve_regex=evolve_regex
    )

    block_assignments: Dict[int, List[int]] = assign_diffs_to_blocks(
        parent_code=parent_code, diff_blocks=diff_blocks, evolve_spans=evolve_spans
    )

    modified_blocks: List[str] = apply_replacements(
        parent_code=parent_code,
        diff_blocks=diff_blocks,
        evolve_spans=evolve_spans,
        block_assignments=block_assignments,
    )

    child_code_parts: List[str] = []
    last_end: int = 0
    for i, (start, end) in enumerate(evolve_spans):
        child_code_parts.append(parent_code[last_end:start])
        child_code_parts.append(modified_blocks[i])
        last_end = end

    child_code_parts.append(parent_code[last_end:])

    return "".join(child_code_parts)
